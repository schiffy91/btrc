/* btrc standard library â€” Strings
 * String utilities beyond the built-in string methods.
 * Built-in: .len(), .contains(), .startsWith(), .endsWith(), .substring(),
 *           .trim(), .toUpper(), .toLower(), .indexOf(), .split(), .charAt(), .equals()
 *
 * Note: repeat/join/replace require C string functions because btrc does not
 * yet support string concatenation or f-string assignment.
 */

class Strings {
    class string repeat(string s, int count) {
        int slen = (int)strlen(s);
        int total = slen * count;
        char* result = (char*)malloc(total + 1);
        for i in range(count) {
            memcpy(result + i * slen, s, slen);
        }
        result[total] = '\0';
        return result;
    }

    class string join(List<string> items, string sep) {
        if (items.len == 0) { return strdup(""); }
        int seplen = (int)strlen(sep);
        int total = 0;
        for i in range(items.len) {
            total = total + (int)strlen(items.get(i));
        }
        total = total + seplen * (items.len - 1);
        char* result = (char*)malloc(total + 1);
        int pos = 0;
        int first_len = (int)strlen(items.get(0));
        memcpy(result, items.get(0), first_len);
        pos = first_len;
        for i in range(1, items.len) {
            memcpy(result + pos, sep, seplen);
            pos = pos + seplen;
            int item_len = (int)strlen(items.get(i));
            memcpy(result + pos, items.get(i), item_len);
            pos = pos + item_len;
        }
        result[pos] = '\0';
        return result;
    }

    class string replace(string s, string old, string replacement) {
        int slen = (int)strlen(s);
        int oldlen = (int)strlen(old);
        int replen = (int)strlen(replacement);
        int cap = slen * 2 + 1;
        char* result = (char*)malloc(cap);
        int rlen = 0;
        int i = 0;
        while (i < slen) {
            if (i + oldlen <= slen && strncmp(s + i, old, oldlen) == 0) {
                while (rlen + replen >= cap) {
                    cap = cap * 2;
                    result = (char*)realloc(result, cap);
                }
                memcpy(result + rlen, replacement, replen);
                rlen = rlen + replen;
                i = i + oldlen;
            } else {
                if (rlen + 1 >= cap) {
                    cap = cap * 2;
                    result = (char*)realloc(result, cap);
                }
                result[rlen] = s[i];
                rlen++;
                i++;
            }
        }
        result[rlen] = '\0';
        return result;
    }

    class bool isDigit(char c) {
        return c >= '0' && c <= '9';
    }

    class bool isAlpha(char c) {
        return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');
    }

    class bool isAlnum(char c) {
        return Strings.isAlpha(c) || Strings.isDigit(c);
    }

    class bool isSpace(char c) {
        return c == ' ' || c == '\t' || c == '\n' || c == '\r';
    }

    class int toInt(string s) {
        return atoi(s);
    }

    class float toFloat(string s) {
        return (float)atof(s);
    }
}
