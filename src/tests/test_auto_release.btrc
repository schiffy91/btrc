/* Test auto-release: scope-exit cleanup for managed variables */
#include <assert.h>

int alive = 0;

class Resource {
    public int id;

    public Resource(int id) {
        self.id = id;
        alive++;
    }

    public void __del__() {
        alive--;
    }
}

class Manager {
    public Resource res;

    public Manager() {
        self.res = null;
    }

    public void setResource(keep Resource r) {
        self.res = r;
    }
}

// Factory function
Resource createResource(int id) {
    Resource r = new Resource(id);
    return r;
}

int main() {
    // Test 1: keep param registers var as managed, scope-exit releases it
    {
        Manager m = new Manager();
        Resource r = new Resource(1);
        assert(alive == 1);

        // keep param â†’ rc++ at call site, registers r as managed
        m.setResource(r);
        assert(alive == 1);

        // At scope exit: r is managed, rc-- (from keep param registration)
        // r's rc: 1 (new) + 1 (keep param) + 1 (field assign) = 3
        // scope exit r: --rc = 2, skip
        // m is not managed (no keep applied), just leave it
        // After scope exit, m and r are leaked without explicit delete
        // (auto-release only happens for managed vars)
        delete m;
        // m destructor: --res->rc, if <=0 destroy
        // res rc goes 3->2, skip
    }
    // r is managed, so scope exit does rc--
    // Wait - r goes out of scope with the block, managed scope pops
    // r's rc after scope exit: 3 - 1 (scope release) = 2
    // Still alive because rc > 0
    assert(alive == 1);

    // Test 2: delete sets var to NULL, scope exit skips null vars
    {
        Resource d = new Resource(2);
        assert(alive == 2);
        delete d;
        assert(d == null);
        assert(alive == 1);
        // scope exit: d is NULL, skip
    }

    // Test 3: keep/release explicit statements
    Resource k = new Resource(3);
    assert(alive == 2);
    keep k;
    // k's rc: 1 (new) + 1 (keep) = 2
    release k;
    // k's rc: 2 - 1 = 1, > 0 so not destroyed. k = NULL
    assert(k == null);
    assert(alive == 2); // not destroyed

    print("PASS: test_auto_release");
    return 0;
}
