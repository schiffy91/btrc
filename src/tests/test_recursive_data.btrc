// Test recursive data structures: linked list, tree
#include <assert.h>

class ListNode {
    public int value;
    public ListNode* next;

    public ListNode(int value) {
        self.value = value;
        self.next = null;
    }
}

class TreeNode {
    public int value;
    public TreeNode* left;
    public TreeNode* right;

    public TreeNode(int value) {
        self.value = value;
        self.left = null;
        self.right = null;
    }
}

// ---- Linked list helpers ----
void list_append(ListNode* head, int value) {
    ListNode* curr = head;
    while (curr->next != null) {
        curr = curr->next;
    }
    curr->next = new ListNode(value);
}

int list_length(ListNode* head) {
    int count = 0;
    ListNode* curr = head;
    while (curr != null) {
        count++;
        curr = curr->next;
    }
    return count;
}

int list_sum(ListNode* head) {
    int sum = 0;
    ListNode* curr = head;
    while (curr != null) {
        sum += curr->value;
        curr = curr->next;
    }
    return sum;
}

void list_free(ListNode* head) {
    // Auto-generated destructor recursively frees next pointers,
    // so just delete the head to clean up the whole chain.
    delete head;
}

// ---- Tree helpers ----
void tree_insert(TreeNode* root, int value) {
    if (value < root->value) {
        if (root->left == null) {
            root->left = new TreeNode(value);
        } else {
            tree_insert(root->left, value);
        }
    } else {
        if (root->right == null) {
            root->right = new TreeNode(value);
        } else {
            tree_insert(root->right, value);
        }
    }
}

int tree_count(TreeNode* node) {
    if (node == null) {
        return 0;
    }
    return 1 + tree_count(node->left) + tree_count(node->right);
}

bool tree_contains(TreeNode* node, int value) {
    if (node == null) {
        return false;
    }
    if (node->value == value) {
        return true;
    }
    if (value < node->value) {
        return tree_contains(node->left, value);
    }
    return tree_contains(node->right, value);
}

void tree_free(TreeNode* node) {
    // Auto-generated destructor recursively frees left/right,
    // so just delete root to clean up the whole tree.
    delete node;
}

int main() {
    // ---- Linked list ----
    ListNode* head = new ListNode(10);
    list_append(head, 20);
    list_append(head, 30);
    list_append(head, 40);

    assert(list_length(head) == 4);
    assert(list_sum(head) == 100);  // 10+20+30+40

    // Walk the list
    assert(head->value == 10);
    assert(head->next->value == 20);
    assert(head->next->next->value == 30);
    assert(head->next->next->next->value == 40);
    assert(head->next->next->next->next == null);

    list_free(head);

    // ---- Binary search tree ----
    TreeNode* root = new TreeNode(50);
    tree_insert(root, 30);
    tree_insert(root, 70);
    tree_insert(root, 20);
    tree_insert(root, 40);
    tree_insert(root, 60);
    tree_insert(root, 80);

    assert(tree_count(root) == 7);
    assert(tree_contains(root, 50) == true);
    assert(tree_contains(root, 30) == true);
    assert(tree_contains(root, 80) == true);
    assert(tree_contains(root, 25) == false);
    assert(tree_contains(root, 99) == false);

    // BST property: left < root < right
    assert(root->left->value == 30);
    assert(root->right->value == 70);
    assert(root->left->left->value == 20);
    assert(root->left->right->value == 40);

    tree_free(root);

    print("PASS: test_recursive_data");
    return 0;
}
