"""C code emitter for the btrc compiler.

Walks an IR tree and serializes it to C text. This is intentionally simple —
all lowering (class layout, generics, method-to-function, etc.) is done
during IR generation. The emitter just formats.
"""

from __future__ import annotations
from .nodes import (
    IRModule,
    IRHelperDecl,
    IRStructDef,
    IRFunctionDef,
    IRBlock,
    IRStmt,
    IRExpr,
    IRVarDecl,
    IRAssign,
    IRReturn,
    IRIf,
    IRWhile,
    IRDoWhile,
    IRFor,
    IRSwitch,
    IRCase,
    IRExprStmt,
    IRRawC,
    IRBreak,
    IRContinue,
    IRLiteral,
    IRVar,
    IRBinOp,
    IRUnaryOp,
    IRCall,
    IRFieldAccess,
    IRCast,
    IRTernary,
    IRSizeof,
    IRIndex,
    IRAddressOf,
    IRDeref,
    IRRawExpr,
    IRStmtExpr,
    IRSpawnThread,
)


class CEmitter:
    """Emits C source text from an IRModule."""

    def __init__(self):
        self._lines: list[str] = []
        self._indent: int = 0

    def emit(self, module: IRModule) -> str:
        """Emit the entire IR module as C source text."""
        self._lines = []
        self._indent = 0

        # Header comment (skip if raw_sections already contain full output)
        if not module.raw_sections:
            self._line("/* Generated by btrc */")

        # Includes
        for inc in module.includes:
            if inc.startswith("#"):
                self._line(inc)
            else:
                self._line(f"#include <{inc}>")
        if module.includes:
            self._line("")

        # Runtime helpers
        for helper in module.helper_decls:
            self._raw(helper.c_source)
            self._line("")

        # Forward declarations
        for fwd in module.forward_decls:
            self._line(fwd)
        if module.forward_decls:
            self._line("")

        # Preprocessor defines (must come before struct defs that use them)
        define_sections = [s for s in module.raw_sections if s.startswith("#define")]
        other_sections = [s for s in module.raw_sections if not s.startswith("#define")]
        for section in define_sections:
            self._raw(section)
            self._line("")

        # Struct definitions
        for struct in module.struct_defs:
            self._emit_struct(struct)

        # VTable definitions
        for vtable in module.vtable_defs:
            self._raw(vtable)
            self._line("")

        # Global variables
        for gvar in module.global_vars:
            self._line(gvar)
        if module.global_vars:
            self._line("")

        # Raw sections (pre-rendered C text, excluding #define)
        for section in other_sections:
            self._raw(section)
            self._line("")

        # Function definitions
        for func in module.function_defs:
            self._emit_function(func)

        return "\n".join(self._lines) + "\n"

    # --- Struct emission ---

    def _emit_struct(self, struct: IRStructDef):
        self._line(f"struct {struct.name} {{")
        self._indent += 1
        for f in struct.fields:
            self._line(f"{f.c_type} {f.name};")
        self._indent -= 1
        self._line("};")
        self._line("")

    # --- Function emission ---

    def _emit_function(self, func: IRFunctionDef):
        params = ", ".join(f"{p.c_type} {p.name}" for p in func.params)
        if not params:
            params = "void"
        prefix = "static " if func.is_static else ""
        self._line(f"{prefix}{func.return_type} {func.name}({params}) {{")
        if func.body:
            self._indent += 1
            self._emit_block_contents(func.body)
            self._indent -= 1
        self._line("}")
        self._line("")

    def _emit_block_contents(self, block: IRBlock):
        for stmt in block.stmts:
            self._emit_stmt(stmt)

    def _emit_block(self, block: IRBlock):
        """Emit a block with braces."""
        self._line("{")
        self._indent += 1
        self._emit_block_contents(block)
        self._indent -= 1
        self._line("}")

    # --- Statement emission ---

    def _emit_stmt(self, stmt: IRStmt):
        if isinstance(stmt, IRVarDecl):
            if stmt.init:
                self._line(f"{stmt.c_type} {stmt.name} = {self._expr(stmt.init)};")
            else:
                self._line(f"{stmt.c_type} {stmt.name};")

        elif isinstance(stmt, IRAssign):
            self._line(f"{self._expr(stmt.target)} = {self._expr(stmt.value)};")

        elif isinstance(stmt, IRReturn):
            if stmt.value:
                self._line(f"return {self._expr(stmt.value)};")
            else:
                self._line("return;")

        elif isinstance(stmt, IRIf):
            self._line(f"if ({self._expr(stmt.condition)}) {{")
            if stmt.then_block:
                self._indent += 1
                self._emit_block_contents(stmt.then_block)
                self._indent -= 1
            if stmt.else_block and stmt.else_block.stmts:
                # Check if else block is a single if statement (else if)
                if (len(stmt.else_block.stmts) == 1
                        and isinstance(stmt.else_block.stmts[0], IRIf)):
                    inner = stmt.else_block.stmts[0]
                    self._line(f"}} else if ({self._expr(inner.condition)}) {{")
                    if inner.then_block:
                        self._indent += 1
                        self._emit_block_contents(inner.then_block)
                        self._indent -= 1
                    if inner.else_block and inner.else_block.stmts:
                        self._line("} else {")
                        self._indent += 1
                        self._emit_block_contents(inner.else_block)
                        self._indent -= 1
                    self._line("}")
                else:
                    self._line("} else {")
                    self._indent += 1
                    self._emit_block_contents(stmt.else_block)
                    self._indent -= 1
                    self._line("}")
            else:
                self._line("}")

        elif isinstance(stmt, IRWhile):
            self._line(f"while ({self._expr(stmt.condition)}) {{")
            if stmt.body:
                self._indent += 1
                self._emit_block_contents(stmt.body)
                self._indent -= 1
            self._line("}")

        elif isinstance(stmt, IRDoWhile):
            self._line("do {")
            if stmt.body:
                self._indent += 1
                self._emit_block_contents(stmt.body)
                self._indent -= 1
            self._line(f"}} while ({self._expr(stmt.condition)});")

        elif isinstance(stmt, IRFor):
            self._line(f"for ({stmt.init}; {stmt.condition}; {stmt.update}) {{")
            if stmt.body:
                self._indent += 1
                self._emit_block_contents(stmt.body)
                self._indent -= 1
            self._line("}")

        elif isinstance(stmt, IRSwitch):
            self._line(f"switch ({self._expr(stmt.value)}) {{")
            self._indent += 1
            for case in stmt.cases:
                if case.value:
                    self._line(f"case {self._expr(case.value)}:")
                else:
                    self._line("default:")
                self._indent += 1
                for s in case.body:
                    self._emit_stmt(s)
                self._indent -= 1
            self._indent -= 1
            self._line("}")

        elif isinstance(stmt, IRExprStmt):
            self._line(f"{self._expr(stmt.expr)};")

        elif isinstance(stmt, IRBreak):
            self._line("break;")

        elif isinstance(stmt, IRContinue):
            self._line("continue;")

        elif isinstance(stmt, IRRawC):
            # Raw C text — emit each line with current indentation
            for raw_line in stmt.text.split("\n"):
                if raw_line.strip():
                    self._line(raw_line)

    # --- Expression emission ---

    def _expr(self, expr: IRExpr) -> str:
        if expr is None:
            return "/* null expr */"

        if isinstance(expr, IRLiteral):
            return expr.text

        elif isinstance(expr, IRVar):
            return expr.name

        elif isinstance(expr, IRBinOp):
            return f"({self._expr(expr.left)} {expr.op} {self._expr(expr.right)})"

        elif isinstance(expr, IRUnaryOp):
            if expr.prefix:
                return f"({expr.op}{self._expr(expr.operand)})"
            else:
                return f"({self._expr(expr.operand)}{expr.op})"

        elif isinstance(expr, IRCall):
            args = ", ".join(self._expr(a) for a in expr.args)
            return f"{expr.callee}({args})"

        elif isinstance(expr, IRFieldAccess):
            op = "->" if expr.arrow else "."
            return f"{self._expr(expr.obj)}{op}{expr.field}"

        elif isinstance(expr, IRCast):
            return f"(({expr.target_type}){self._expr(expr.expr)})"

        elif isinstance(expr, IRTernary):
            return (f"({self._expr(expr.condition)} ? "
                    f"{self._expr(expr.true_expr)} : "
                    f"{self._expr(expr.false_expr)})")

        elif isinstance(expr, IRSizeof):
            return f"sizeof({expr.operand})"

        elif isinstance(expr, IRIndex):
            return f"{self._expr(expr.obj)}[{self._expr(expr.index)}]"

        elif isinstance(expr, IRAddressOf):
            return f"(&{self._expr(expr.expr)})"

        elif isinstance(expr, IRDeref):
            return f"(*{self._expr(expr.expr)})"

        elif isinstance(expr, IRRawExpr):
            return expr.text

        elif isinstance(expr, IRStmtExpr):
            parts = [self._stmt_text(s) for s in expr.stmts]
            parts.append(f"{self._expr(expr.result)};")
            return "({ " + " ".join(parts) + " })"

        elif isinstance(expr, IRSpawnThread):
            arg = self._expr(expr.capture_arg) if expr.capture_arg else "NULL"
            return f"__btrc_thread_spawn((void*(*)(void*)){expr.fn_ptr}, {arg})"

        return f"/* unknown expr: {type(expr).__name__} */"

    # --- Statement expression helpers ---

    def _stmt_text(self, stmt):
        """Render a single IRStmt as inline text for use inside statement expressions."""
        if isinstance(stmt, IRVarDecl):
            if stmt.init:
                return f"{stmt.c_type.text} {stmt.name} = {self._expr(stmt.init)};"
            return f"{stmt.c_type.text} {stmt.name};"
        elif isinstance(stmt, IRExprStmt):
            return f"{self._expr(stmt.expr)};"
        elif isinstance(stmt, IRAssign):
            return f"{self._expr(stmt.target)} = {self._expr(stmt.value)};"
        elif isinstance(stmt, IRIf):
            cond = self._expr(stmt.condition)
            body = " ".join(self._stmt_text(s) for s in stmt.then_block.stmts)
            return f"if ({cond}) {{ {body} }}"
        return "/* unknown stmt */;"

    # --- Output helpers ---

    def _line(self, text: str):
        """Emit a line with current indentation."""
        if text.strip():
            self._lines.append("    " * self._indent + text)
        else:
            self._lines.append("")

    def _raw(self, text: str):
        """Emit raw text without indentation adjustment."""
        for line in text.rstrip("\n").split("\n"):
            self._lines.append(line)
