"""C code emitter for the btrc compiler.

Walks an IR tree and serializes it to C text. This is intentionally simple --
all lowering (class layout, generics, method-to-function, etc.) is done
during IR generation. The emitter just formats.
"""

from __future__ import annotations

from .emitter_exprs import _ExprEmitterMixin
from .emitter_gpu import _GpuEmitterMixin
from .nodes import (
    IRAssign,
    IRBlock,
    IRBreak,
    IRContinue,
    IRDoWhile,
    IREnumDef,
    IRExprStmt,
    IRFor,
    IRFunctionDef,
    IRGpuKernel,
    IRIf,
    IRModule,
    IRRawC,
    IRReturn,
    IRStmt,
    IRStructDef,
    IRSwitch,
    IRVarDecl,
    IRWhile,
)


class CEmitter(_GpuEmitterMixin, _ExprEmitterMixin):
    """Emits C source text from an IRModule."""

    def __init__(self):
        self._lines: list[str] = []
        self._indent: int = 0

    def emit(self, module: IRModule) -> str:
        """Emit the entire IR module as C source text."""
        self._lines = []
        self._indent = 0

        # Header comment (skip if raw_sections already contain full output)
        if not module.raw_sections:
            self._line("/* Generated by btrc */")

        # Includes
        for inc in module.includes:
            if inc.startswith("#"):
                self._line(inc)
            else:
                self._line(f"#include <{inc}>")
        if module.includes:
            self._line("")

        # Runtime helpers
        for helper in module.helper_decls:
            self._raw(helper.c_source)
            self._line("")

        # Preprocessor defines (must come before struct defs that use them)
        define_sections = [s for s in module.raw_sections if s.startswith("#define")]
        other_sections = [s for s in module.raw_sections if not s.startswith("#define")]
        for section in define_sections:
            self._raw(section)
            self._line("")

        # Enum definitions (before forward decls, since functions may reference enum types)
        for enum in module.enum_defs:
            self._emit_enum_def(enum)

        # Forward declarations
        for fwd in module.forward_decls:
            self._line(fwd)
        if module.forward_decls:
            self._line("")

        # Struct definitions
        for struct in module.struct_defs:
            self._emit_struct(struct)

        # VTable definitions
        for vtable in module.vtable_defs:
            self._raw(vtable)
            self._line("")

        # Global variables
        for gvar in module.global_vars:
            self._line(gvar)
        if module.global_vars:
            self._line("")

        # Raw sections (pre-rendered C text, excluding #define)
        for section in other_sections:
            self._raw(section)
            self._line("")

        # GPU kernel WGSL string constants
        for kernel in module.gpu_kernels:
            self._emit_gpu_kernel(kernel)

        # Function definitions
        for func in module.function_defs:
            self._emit_function(func)

        return "\n".join(self._lines) + "\n"

    # --- Enum emission ---

    def _emit_enum_def(self, enum: IREnumDef):
        self._line("typedef enum {")
        self._indent += 1
        for i, v in enumerate(enum.values):
            comma = "," if i < len(enum.values) - 1 else ""
            if v.value:
                self._line(f"{v.name} = {v.value}{comma}")
            else:
                self._line(f"{v.name}{comma}")
        self._indent -= 1
        self._line(f"}} {enum.name};")
        self._line("")

    # --- Struct emission ---

    def _emit_struct(self, struct: IRStructDef):
        self._line(f"struct {struct.name} {{")
        self._indent += 1
        for f in struct.fields:
            self._line(f"{f.c_type} {f.name};")
        self._indent -= 1
        self._line("};")
        self._line("")

    # --- Function emission ---

    def _emit_function(self, func: IRFunctionDef):
        params = ", ".join(f"{p.c_type} {p.name}" for p in func.params)
        if not params:
            params = "void"
        prefix = "static " if func.is_static else ""
        self._line(f"{prefix}{func.return_type} {func.name}({params}) {{")
        if func.body:
            self._indent += 1
            self._emit_block_contents(func.body)
            self._indent -= 1
        self._line("}")
        self._line("")

    def _emit_block_contents(self, block: IRBlock):
        for stmt in block.stmts:
            self._emit_stmt(stmt)

    def _emit_block(self, block: IRBlock):
        """Emit a block with braces."""
        self._line("{")
        self._indent += 1
        self._emit_block_contents(block)
        self._indent -= 1
        self._line("}")

    # --- Statement emission ---

    def _emit_stmt(self, stmt: IRStmt):
        if isinstance(stmt, IRVarDecl):
            if stmt.is_volatile:
                ct = str(stmt.c_type)
                # For pointer types, volatile must go after the * to make
                # the pointer itself volatile (not the pointed-to data).
                # e.g. Item* volatile it (volatile pointer to Item)
                # vs   volatile Item* it (pointer to volatile Item)
                if ct.endswith("*"):
                    vol_type = f"{ct} volatile"
                else:
                    vol_type = f"volatile {ct}"
                if stmt.init:
                    self._line(f"{vol_type} {stmt.name} = {self._expr(stmt.init)};")
                else:
                    self._line(f"{vol_type} {stmt.name};")
            else:
                if stmt.init:
                    self._line(f"{stmt.c_type} {stmt.name} = {self._expr(stmt.init)};")
                else:
                    self._line(f"{stmt.c_type} {stmt.name};")

        elif isinstance(stmt, IRAssign):
            self._line(f"{self._expr(stmt.target)} = {self._expr(stmt.value)};")

        elif isinstance(stmt, IRReturn):
            if stmt.value:
                self._line(f"return {self._expr(stmt.value)};")
            else:
                self._line("return;")

        elif isinstance(stmt, IRIf):
            self._line(f"if ({self._cond_expr(stmt.condition)}) {{")
            if stmt.then_block:
                self._indent += 1
                self._emit_block_contents(stmt.then_block)
                self._indent -= 1
            self._emit_else_tail(stmt)

        elif isinstance(stmt, IRWhile):
            self._line(f"while ({self._cond_expr(stmt.condition)}) {{")
            if stmt.body:
                self._indent += 1
                self._emit_block_contents(stmt.body)
                self._indent -= 1
            self._line("}")

        elif isinstance(stmt, IRDoWhile):
            self._line("do {")
            if stmt.body:
                self._indent += 1
                self._emit_block_contents(stmt.body)
                self._indent -= 1
            self._line(f"}} while ({self._cond_expr(stmt.condition)});")

        elif isinstance(stmt, IRFor):
            init_text = ""
            if stmt.init:
                if isinstance(stmt.init, IRVarDecl):
                    if stmt.init.init:
                        init_text = f"{stmt.init.c_type} {stmt.init.name} = {self._expr(stmt.init.init)}"
                    else:
                        init_text = f"{stmt.init.c_type} {stmt.init.name}"
                elif isinstance(stmt.init, IRAssign):
                    init_text = f"{self._expr(stmt.init.target)} = {self._expr(stmt.init.value)}"
                elif isinstance(stmt.init, IRExprStmt):
                    init_text = self._expr(stmt.init.expr)
            cond_text = self._expr(stmt.condition) if stmt.condition else ""
            update_text = self._expr(stmt.update) if stmt.update else ""
            self._line(f"for ({init_text}; {cond_text}; {update_text}) {{")
            if stmt.body:
                self._indent += 1
                self._emit_block_contents(stmt.body)
                self._indent -= 1
            self._line("}")

        elif isinstance(stmt, IRSwitch):
            self._line(f"switch ({self._expr(stmt.value)}) {{")
            self._indent += 1
            for case in stmt.cases:
                if case.value:
                    self._line(f"case {self._expr(case.value)}:")
                else:
                    self._line("default:")
                self._indent += 1
                for s in case.body:
                    self._emit_stmt(s)
                self._indent -= 1
            self._indent -= 1
            self._line("}")

        elif isinstance(stmt, IRExprStmt):
            self._line(f"{self._expr(stmt.expr)};")

        elif isinstance(stmt, IRBreak):
            self._line("break;")

        elif isinstance(stmt, IRContinue):
            self._line("continue;")

        elif isinstance(stmt, IRGpuKernel):
            self._emit_gpu_kernel(stmt)

        elif isinstance(stmt, IRRawC):
            # Raw C text -- emit each line with current indentation
            for raw_line in stmt.text.split("\n"):
                if raw_line.strip():
                    self._line(raw_line)

    def _emit_else_tail(self, stmt: IRIf):
        """Emit the else / else-if tail of an IRIf, recursing for chains."""
        if not stmt.else_block or not stmt.else_block.stmts:
            self._line("}")
            return
        # else-if: single IRIf inside the else block
        if (len(stmt.else_block.stmts) == 1
                and isinstance(stmt.else_block.stmts[0], IRIf)):
            inner = stmt.else_block.stmts[0]
            self._line(f"}} else if ({self._cond_expr(inner.condition)}) {{")
            if inner.then_block:
                self._indent += 1
                self._emit_block_contents(inner.then_block)
                self._indent -= 1
            self._emit_else_tail(inner)
        else:
            self._line("} else {")
            self._indent += 1
            self._emit_block_contents(stmt.else_block)
            self._indent -= 1
            self._line("}")

    # --- Output helpers ---

    def _line(self, text: str):
        """Emit a line with current indentation."""
        if text.strip():
            self._lines.append("    " * self._indent + text)
        else:
            self._lines.append("")

    def _raw(self, text: str):
        """Emit raw text without indentation adjustment."""
        for line in text.rstrip("\n").split("\n"):
            self._lines.append(line)
