/* btrc self-hosted compiler — Semantic Analyzer
 *
 * Responsibilities:
 * - Build class table (fields, methods, constructor, parent)
 * - Register top-level functions
 * - Collect generic instantiations for monomorphization
 * - Infer types for 'var' declarations
 * - Validate access control (public/private/class)
 * - Validate self usage
 *
 * Since the AST arena is immutable after parsing, results are stored
 * in separate data structures:
 *   - class_table: Map<string, int> → class info node indices
 *   - generic_instances: collected as mangled name strings in a List
 *   - var_types: Map<int, int> → node index → inferred type node index
 */

/* ---- ClassInfo: stores class metadata ---- */

class ClassInfo {
    public string name;
    public List<string> generic_params;
    public List<string> field_names;
    public List<int> field_types;      /* type node index for each field */
    public List<string> field_access;  /* "public" or "private" */
    public List<string> method_names;
    public List<int> method_ret_types; /* return type node index */
    public List<string> method_access; /* "public", "private", or "class" */
    public List<int> method_nodes;     /* method decl node index in arena */
    public List<string> prop_names;
    public List<int> prop_types;       /* type node index for each property */
    public List<int> prop_nodes;       /* NK_PROPERTY_DECL node index in arena */
    public bool has_constructor;
    public string parent;

    public ClassInfo(string name) {
        self.name = name;
        self.generic_params = [];
        self.field_names = [];
        self.field_types = [];
        self.field_access = [];
        self.method_names = [];
        self.method_ret_types = [];
        self.method_access = [];
        self.method_nodes = [];
        self.prop_names = [];
        self.prop_types = [];
        self.prop_nodes = [];
        self.has_constructor = false;
        self.parent = "";
    }

    public void add_field(string fname, int type_idx, string access) {
        self.field_names.push(fname);
        self.field_types.push(type_idx);
        self.field_access.push(access);
    }

    public void add_method(string mname, int ret_type, string access, int node_idx) {
        self.method_names.push(mname);
        self.method_ret_types.push(ret_type);
        self.method_access.push(access);
        self.method_nodes.push(node_idx);
    }

    public void add_property(string pname, int type_idx, int node_idx) {
        self.prop_names.push(pname);
        self.prop_types.push(type_idx);
        self.prop_nodes.push(node_idx);
    }

    public int find_field(string fname) {
        for (int i = 0; i < self.field_names.len; i++) {
            string f = self.field_names.get(i);
            if (f.equals(fname)) {
                return i;
            }
        }
        return -1;
    }

    public int find_method(string mname) {
        for (int i = 0; i < self.method_names.len; i++) {
            string m = self.method_names.get(i);
            if (m.equals(mname)) {
                return i;
            }
        }
        return -1;
    }

    public int find_property(string pname) {
        for (int i = 0; i < self.prop_names.len; i++) {
            string p = self.prop_names.get(i);
            if (p.equals(pname)) {
                return i;
            }
        }
        return -1;
    }
}

/* ---- SymbolInfo: variable/param/function in scope ---- */

class SymbolInfo {
    public string name;
    public int type_idx;   /* type node index, or -1 */
    public string kind;    /* "variable", "param", "function" */

    public SymbolInfo(string name, int type_idx, string kind) {
        self.name = name;
        self.type_idx = type_idx;
        self.kind = kind;
    }
}

/* ---- Scope: nested scope for symbol lookup ---- */

class Scope {
    public List<string> names;
    public List<int> type_indices;
    public List<string> kinds;
    public int parent_start;  /* index into analyzer's scope stack */

    public Scope() {
        self.names = [];
        self.type_indices = [];
        self.kinds = [];
        self.parent_start = -1;
    }

    public void define(string name, int type_idx, string kind) {
        self.names.push(name);
        self.type_indices.push(type_idx);
        self.kinds.push(kind);
    }

    public int lookup_local(string name) {
        for (int i = self.names.len - 1; i >= 0; i--) {
            string n = self.names.get(i);
            if (n.equals(name)) {
                return self.type_indices.get(i);
            }
        }
        return -2; /* not found sentinel (since -1 is valid for untyped) */
    }
}

/* ---- Analyzer ---- */

class Analyzer {
    public List<Node> nodes;       /* shared AST arena from parser */
    private List<ClassInfo> classes;
    private List<string> class_names;
    private Map<string, int> class_map;       /* class name → index in classes list */
    private Map<string, int> function_table;  /* func name → return type node index */
    private List<string> generic_instance_keys;  /* mangled generic instance names for dedup */
    public List<string> errors;

    /* Flat symbol table: avoids by-value scope copy issues */
    private List<string> sym_names;
    private List<int> sym_types;
    private List<string> sym_kinds;
    private List<int> scope_starts; /* sym_names index where each scope begins */
    private int scope_depth;

    /* Current context (public so codegen can set class name for type inference) */
    public string current_class_name;
    private string current_method_access;

    /* Results: var type inference → stored as new type nodes appended to arena */
    public Map<int, int> var_types;  /* var_decl node index → inferred type node index */
    public Map<int, int> node_types; /* expr node index → resolved type node index (for codegen) */

    public Analyzer(List<Node> nodes) {
        self.nodes = nodes;
        self.classes = [];
        self.class_names = [];
        self.class_map = {};
        self.function_table = {};
        self.generic_instance_keys = [];
        self.errors = [];
        self.sym_names = [];
        self.sym_types = [];
        self.sym_kinds = [];
        self.scope_starts = [];
        self.scope_depth = 0;
        self.current_class_name = "";
        self.current_method_access = "";
        self.var_types = {};
        self.node_types = {};

        /* Push global scope */
        self.scope_starts.push(0);
        self.scope_depth = 1;
    }

    /* ---- Main entry point ---- */

    public void analyze(int program_idx) {
        Node prog = self.nodes.get(program_idx);

        /* Pass 1: Register all classes and functions */
        for (int i = 0; i < prog.items.len; i++) {
            int decl_idx = prog.items.get(i);
            Node decl = self.nodes.get(decl_idx);
            if (decl.kind == NK_CLASS_DECL) {
                self.register_class(decl_idx);
            } else if (decl.kind == NK_FUNC_DECL) {
                self.register_function(decl_idx);
            }
        }

        /* Pass 2: Analyze bodies */
        for (int i = 0; i < prog.items.len; i++) {
            int decl_idx = prog.items.get(i);
            self.analyze_decl(decl_idx);
        }
    }

    private void add_error(string msg, int line, int col) {
        char buf[512];
        snprintf(buf, sizeof(buf), "%s at %d:%d", msg, line, col);
        self.errors.push(strdup(buf));
    }

    /* ---- Scope management (flat symbol table) ---- */

    private void push_scope() {
        self.scope_starts.push(self.sym_names.len);
        self.scope_depth++;
    }

    private void pop_scope() {
        if (self.scope_depth > 1) {
            self.scope_depth--;
        }
    }

    /* Lookup a name across all active scopes (search backwards) */
    private int scope_lookup(string name) {
        /* Search from end of symbol table back to start of first active scope */
        int search_start = self.scope_starts.get(0);
        for (int i = self.sym_names.len - 1; i >= search_start; i--) {
            string sn = self.sym_names.get(i);
            if (sn.equals(name)) {
                return self.sym_types.get(i);
            }
        }
        return -2; /* not found */
    }

    private void scope_define(string name, int type_idx, string kind) {
        self.sym_names.push(name);
        self.sym_types.push(type_idx);
        self.sym_kinds.push(kind);
    }

    /* ---- Pass 1: Registration ---- */

    private void register_class(int class_idx) {
        Node decl = self.nodes.get(class_idx);
        var info = ClassInfo(decl.name);

        /* Generic params */
        for (int i = 0; i < decl.items2.len; i++) {
            Node gp = self.nodes.get(decl.items2.get(i));
            info.generic_params.push(gp.name);
        }

        /* Parent class */
        if (decl.name2.len() > 0) {
            info.parent = decl.name2;
            /* Inherit from parent if already registered */
            if (self.class_map.has(decl.name2)) {
                int pidx = self.class_map.get(decl.name2);
                ClassInfo parent = self.classes.get(pidx);
                /* Inherit fields */
                for (int i = 0; i < parent.field_names.len; i++) {
                    info.add_field(parent.field_names.get(i),
                                   parent.field_types.get(i),
                                   parent.field_access.get(i));
                }
                /* Inherit methods (except constructor) */
                for (int i = 0; i < parent.method_names.len; i++) {
                    string mname = parent.method_names.get(i);
                    if (!mname.equals(parent.name)) {
                        info.add_method(mname,
                                        parent.method_ret_types.get(i),
                                        parent.method_access.get(i),
                                        parent.method_nodes.get(i));
                    }
                }
            }
        }

        /* Register own members */
        for (int i = 0; i < decl.items.len; i++) {
            int member_idx = decl.items.get(i);
            Node member = self.nodes.get(member_idx);
            if (member.kind == NK_FIELD_DECL) {
                /* Check if field already exists (inherited), override it */
                int existing = info.find_field(member.name);
                if (existing >= 0) {
                    /* Override: we can't modify the list in place easily,
                       but since child overrides parent, we just skip —
                       the parent version is already there. For simplicity,
                       add a new entry; find_field returns first match.
                       Actually we want the LAST match to win... Let's just add it.
                       In find_field, we search forward, so last added wins if we
                       change to reverse search. Let's keep it simple and not override. */
                }
                info.add_field(member.name, member.n1, member.sval);
            } else if (member.kind == NK_METHOD_DECL) {
                if (member.name.equals(decl.name)) {
                    info.has_constructor = true;
                }
                info.add_method(member.name, member.n1, member.sval, member_idx);
            } else if (member.kind == NK_PROPERTY_DECL) {
                info.add_property(member.name, member.n1, member_idx);
            }
        }

        int cidx = self.classes.len;
        self.classes.push(info);
        self.class_names.push(decl.name);
        self.class_map.put(decl.name, cidx);
    }

    private void register_function(int func_idx) {
        Node decl = self.nodes.get(func_idx);
        self.function_table.put(decl.name, decl.n1);
    }

    /* ---- Pass 2: Analysis ---- */

    private void analyze_decl(int decl_idx) {
        Node decl = self.nodes.get(decl_idx);

        if (decl.kind == NK_CLASS_DECL) {
            self.analyze_class(decl_idx);
        } else if (decl.kind == NK_FUNC_DECL) {
            self.analyze_function(decl_idx);
        } else if (decl.kind == NK_VAR_DECL) {
            self.analyze_var_decl(decl_idx);
        }
        /* PreprocessorDirective, StructDecl, EnumDecl, TypedefDecl — no analysis needed */
    }

    private void analyze_class(int class_idx) {
        Node decl = self.nodes.get(class_idx);
        string prev_class = self.current_class_name;
        self.current_class_name = decl.name;

        for (int i = 0; i < decl.items.len; i++) {
            int member_idx = decl.items.get(i);
            Node member = self.nodes.get(member_idx);
            if (member.kind == NK_FIELD_DECL) {
                self.collect_generic_instances_from_type(member.n1);
                if (member.n2 != -1) {
                    self.analyze_expr(member.n2);
                }
            } else if (member.kind == NK_METHOD_DECL) {
                self.analyze_method(member_idx);
            } else if (member.kind == NK_PROPERTY_DECL) {
                self.analyze_property(member_idx);
            }
        }

        self.current_class_name = prev_class;
    }

    private void analyze_property(int prop_idx) {
        Node prop = self.nodes.get(prop_idx);
        self.collect_generic_instances_from_type(prop.n1);
        /* Analyze custom getter body */
        if (prop.flag1 && prop.n2 != -1) {
            self.push_scope();
            /* Define self */
            Node self_type = Node(NK_TYPE, prop.line, prop.col);
            self_type.name = self.current_class_name;
            self_type.ival = 1; /* pointer */
            int self_type_idx = self.nodes.len;
            self.nodes.push(self_type);
            self.scope_define("self", self_type_idx, "param");
            self.analyze_block(prop.n2);
            self.pop_scope();
        }
        /* Analyze custom setter body */
        if (prop.flag2 && prop.n3 != -1) {
            self.push_scope();
            /* Define self */
            Node self_type = Node(NK_TYPE, prop.line, prop.col);
            self_type.name = self.current_class_name;
            self_type.ival = 1; /* pointer */
            int self_type_idx = self.nodes.len;
            self.nodes.push(self_type);
            self.scope_define("self", self_type_idx, "param");
            /* Define value */
            self.scope_define("value", prop.n1, "param");
            self.analyze_block(prop.n3);
            self.pop_scope();
        }
    }

    private void analyze_method(int method_idx) {
        Node method = self.nodes.get(method_idx);
        string prev_access = self.current_method_access;
        self.current_method_access = method.sval;

        self.push_scope();

        /* Add 'self' to scope for non-static methods */
        if (!method.sval.equals("class")) {
            /* Create a type node for self: ClassName* */
            Node self_type = Node(NK_TYPE, method.line, method.col);
            self_type.name = self.current_class_name;
            self_type.ival = 1; /* pointer_depth = 1 */
            int self_type_idx = self.nodes.len;
            self.nodes.push(self_type);
            self.scope_define("self", self_type_idx, "param");
        }

        /* Add params to scope */
        for (int i = 0; i < method.items.len; i++) {
            int param_idx = method.items.get(i);
            Node param = self.nodes.get(param_idx);
            self.collect_generic_instances_from_type(param.n1);
            self.scope_define(param.name, param.n1, "param");
        }

        /* Analyze body */
        self.collect_generic_instances_from_type(method.n1);
        self.analyze_block(method.n2);

        self.pop_scope();
        self.current_method_access = prev_access;
    }

    private void analyze_function(int func_idx) {
        Node func = self.nodes.get(func_idx);

        self.push_scope();

        /* Register in scope */
        self.scope_define(func.name, func.n1, "function");

        /* Add params */
        for (int i = 0; i < func.items.len; i++) {
            int param_idx = func.items.get(i);
            Node param = self.nodes.get(param_idx);
            self.collect_generic_instances_from_type(param.n1);
            self.scope_define(param.name, param.n1, "param");
        }

        self.collect_generic_instances_from_type(func.n1);
        self.analyze_block(func.n2);

        self.pop_scope();
    }

    private void analyze_block(int block_idx) {
        if (block_idx == -1) { return; }
        Node block = self.nodes.get(block_idx);
        if (block.kind != NK_BLOCK) { return; }

        self.push_scope();
        for (int i = 0; i < block.items.len; i++) {
            self.analyze_stmt(block.items.get(i));
        }
        self.pop_scope();
    }

    /* ---- Statements ---- */

    private void analyze_stmt(int stmt_idx) {
        if (stmt_idx == -1) { return; }
        Node stmt = self.nodes.get(stmt_idx);

        if (stmt.kind == NK_VAR_DECL) {
            self.analyze_var_decl(stmt_idx);
        } else if (stmt.kind == NK_RETURN) {
            if (stmt.n1 != -1) {
                self.analyze_expr(stmt.n1);
            }
        } else if (stmt.kind == NK_IF) {
            self.analyze_expr(stmt.n1);
            self.analyze_block(stmt.n2);
            if (stmt.n3 != -1) {
                Node else_node = self.nodes.get(stmt.n3);
                if (else_node.kind == NK_IF) {
                    self.analyze_stmt(stmt.n3);
                } else {
                    self.analyze_block(stmt.n3);
                }
            }
        } else if (stmt.kind == NK_WHILE) {
            self.analyze_expr(stmt.n1);
            self.analyze_block(stmt.n2);
        } else if (stmt.kind == NK_DO_WHILE) {
            self.analyze_block(stmt.n1);
            self.analyze_expr(stmt.n2);
        } else if (stmt.kind == NK_FOR_IN) {
            self.analyze_for_in(stmt_idx);
        } else if (stmt.kind == NK_PARALLEL_FOR) {
            self.analyze_parallel_for(stmt_idx);
        } else if (stmt.kind == NK_C_FOR) {
            self.analyze_c_for(stmt_idx);
        } else if (stmt.kind == NK_SWITCH) {
            self.analyze_expr(stmt.n1);
            for (int i = 0; i < stmt.items.len; i++) {
                int case_idx = stmt.items.get(i);
                Node case_node = self.nodes.get(case_idx);
                if (case_node.n1 != -1) {
                    self.analyze_expr(case_node.n1);
                }
                for (int j = 0; j < case_node.items.len; j++) {
                    self.analyze_stmt(case_node.items.get(j));
                }
            }
        } else if (stmt.kind == NK_EXPR_STMT) {
            self.analyze_expr(stmt.n1);
        } else if (stmt.kind == NK_DELETE_STMT) {
            self.analyze_expr(stmt.n1);
        } else if (stmt.kind == NK_BLOCK) {
            self.analyze_block(stmt_idx);
        } else if (stmt.kind == NK_TRY_CATCH) {
            self.analyze_block(stmt.n1);
            self.push_scope();
            /* catch variable is a string */
            Node catch_type = Node(NK_TYPE, stmt.line, stmt.col);
            catch_type.name = "string";
            int catch_type_idx = self.nodes.len;
            self.nodes.push(catch_type);
            self.scope_define(stmt.name, catch_type_idx, "variable");
            self.analyze_block(stmt.n2);
            self.pop_scope();
        } else if (stmt.kind == NK_THROW) {
            self.analyze_expr(stmt.n1);
        }
        /* NK_BREAK, NK_CONTINUE — nothing to analyze */
    }

    private void analyze_var_decl(int var_idx) {
        Node stmt = self.nodes.get(var_idx);

        /* Handle 'var' type inference: n1 == -1 means declared with 'var' */
        if (stmt.n1 == -1) {
            if (stmt.n2 == -1) {
                self.add_error("'var' declaration requires an initializer", stmt.line, stmt.col);
                /* Create fallback int type */
                Node fb = Node(NK_TYPE, stmt.line, stmt.col);
                fb.name = "int";
                int fb_idx = self.nodes.len;
                self.nodes.push(fb);
                self.var_types.put(var_idx, fb_idx);
                self.scope_define(stmt.name, fb_idx, "variable");
                return;
            }
            self.analyze_expr(stmt.n2);
            int inferred = self.infer_type(stmt.n2);
            if (inferred == -1) {
                self.add_error("Cannot infer type for 'var' declaration", stmt.line, stmt.col);
                Node fb = Node(NK_TYPE, stmt.line, stmt.col);
                fb.name = "int";
                int fb_idx = self.nodes.len;
                self.nodes.push(fb);
                self.var_types.put(var_idx, fb_idx);
                self.scope_define(stmt.name, fb_idx, "variable");
            } else {
                self.var_types.put(var_idx, inferred);
                self.collect_generic_instances_from_type(inferred);
                self.scope_define(stmt.name, inferred, "variable");
            }
            return;
        }

        self.collect_generic_instances_from_type(stmt.n1);
        if (stmt.n2 != -1) {
            self.analyze_expr(stmt.n2);
        }
        self.scope_define(stmt.name, stmt.n1, "variable");
    }

    private void analyze_for_in(int stmt_idx) {
        Node stmt = self.nodes.get(stmt_idx);
        self.analyze_expr(stmt.n1);

        int elem_type = -1;

        /* Check for range() call */
        if (self.is_range_call(stmt.n1)) {
            Node rt = Node(NK_TYPE, stmt.line, stmt.col);
            rt.name = "int";
            elem_type = self.nodes.len;
            self.nodes.push(rt);
        } else {
            int iter_type = self.infer_type(stmt.n1);
            elem_type = self.get_element_type(iter_type, stmt.line, stmt.col);
        }

        self.push_scope();
        if (elem_type != -1) {
            self.scope_define(stmt.name, elem_type, "variable");
        }
        self.analyze_block(stmt.n2);
        self.pop_scope();
    }

    private bool is_range_call(int expr_idx) {
        if (expr_idx == -1) { return false; }
        Node expr = self.nodes.get(expr_idx);
        if (expr.kind != NK_CALL) { return false; }
        if (expr.n1 == -1) { return false; }
        Node callee = self.nodes.get(expr.n1);
        return callee.kind == NK_IDENTIFIER && callee.name.equals("range");
    }

    private void analyze_parallel_for(int stmt_idx) {
        Node stmt = self.nodes.get(stmt_idx);
        self.analyze_expr(stmt.n1);

        int iter_type = self.infer_type(stmt.n1);
        int elem_type = self.get_element_type(iter_type, stmt.line, stmt.col);

        self.push_scope();
        if (elem_type != -1) {
            self.scope_define(stmt.name, elem_type, "variable");
        }
        self.analyze_block(stmt.n2);
        self.pop_scope();
    }

    private void analyze_c_for(int stmt_idx) {
        Node stmt = self.nodes.get(stmt_idx);
        self.push_scope();
        if (stmt.n1 != -1) {
            Node init = self.nodes.get(stmt.n1);
            if (init.kind == NK_VAR_DECL) {
                self.analyze_var_decl(stmt.n1);
            } else {
                self.analyze_expr(stmt.n1);
            }
        }
        if (stmt.n2 != -1) {
            self.analyze_expr(stmt.n2);
        }
        if (stmt.n3 != -1) {
            self.analyze_expr(stmt.n3);
        }
        self.analyze_block(stmt.n4);
        self.pop_scope();
    }

    /* ---- Expressions ---- */

    private void analyze_expr(int expr_idx) {
        if (expr_idx == -1) { return; }
        Node expr = self.nodes.get(expr_idx);

        if (expr.kind == NK_INT_LIT || expr.kind == NK_FLOAT_LIT ||
            expr.kind == NK_STRING_LIT || expr.kind == NK_CHAR_LIT ||
            expr.kind == NK_BOOL_LIT || expr.kind == NK_NULL_LIT) {
            /* literals — nothing to analyze */
        } else if (expr.kind == NK_IDENTIFIER) {
            /* Cache identifier type for codegen (scope won't be active later) */
            self.infer_type(expr_idx);
        } else if (expr.kind == NK_SELF) {
            self.validate_self(expr);
        } else if (expr.kind == NK_BINARY) {
            self.analyze_expr(expr.n1);
            self.analyze_expr(expr.n2);
            /* Cache operand types for codegen (scope_lookup won't work later) */
            self.infer_type(expr.n1);
            self.infer_type(expr.n2);
        } else if (expr.kind == NK_UNARY) {
            self.analyze_expr(expr.n1);
        } else if (expr.kind == NK_CALL) {
            self.analyze_call(expr_idx);
        } else if (expr.kind == NK_INDEX) {
            self.analyze_expr(expr.n1);
            self.analyze_expr(expr.n2);
        } else if (expr.kind == NK_FIELD_ACCESS) {
            self.analyze_field_access(expr_idx);
        } else if (expr.kind == NK_ASSIGN) {
            self.analyze_expr(expr.n1);
            self.analyze_expr(expr.n2);
        } else if (expr.kind == NK_TERNARY) {
            self.analyze_expr(expr.n1);
            self.analyze_expr(expr.n2);
            self.analyze_expr(expr.n3);
        } else if (expr.kind == NK_CAST) {
            self.collect_generic_instances_from_type(expr.n1);
            self.analyze_expr(expr.n2);
        } else if (expr.kind == NK_SIZEOF) {
            if (expr.flag1) {
                self.collect_generic_instances_from_type(expr.n1);
            } else {
                self.analyze_expr(expr.n1);
            }
        } else if (expr.kind == NK_LIST_LIT) {
            for (int i = 0; i < expr.items.len; i++) {
                self.analyze_expr(expr.items.get(i));
            }
        } else if (expr.kind == NK_MAP_LIT) {
            for (int i = 0; i < expr.items.len; i++) {
                self.analyze_expr(expr.items.get(i));
                self.analyze_expr(expr.items2.get(i));
            }
        } else if (expr.kind == NK_FSTRING) {
            for (int i = 0; i < expr.items.len; i++) {
                int part_idx = expr.items.get(i);
                Node part = self.nodes.get(part_idx);
                if (part.kind != NK_STRING_LIT) {
                    self.analyze_expr(part_idx);
                }
            }
        } else if (expr.kind == NK_TUPLE_LIT) {
            for (int i = 0; i < expr.items.len; i++) {
                self.analyze_expr(expr.items.get(i));
            }
            /* Collect Tuple generic instance */
            self.collect_tuple_instance(expr_idx);
        } else if (expr.kind == NK_NEW) {
            self.collect_generic_instances_from_type(expr.n1);
            for (int i = 0; i < expr.items.len; i++) {
                self.analyze_expr(expr.items.get(i));
            }
            /* Validate constructor */
            if (expr.n1 != -1) {
                Node type_node = self.nodes.get(expr.n1);
                if (self.class_map.has(type_node.name)) {
                    int cidx = self.class_map.get(type_node.name);
                    ClassInfo cls = self.classes.get(cidx);
                    if (!cls.has_constructor && expr.items.len > 0) {
                        self.add_error("Class has no constructor", expr.line, expr.col);
                    }
                }
            }
        } else if (expr.kind == NK_ADDRESS_OF || expr.kind == NK_DEREF) {
            self.analyze_expr(expr.n1);
        } else if (expr.kind == NK_BRACE_INIT) {
            for (int i = 0; i < expr.items.len; i++) {
                self.analyze_expr(expr.items.get(i));
            }
        } else if (expr.kind == NK_LAMBDA) {
            self.analyze_lambda(expr_idx);
        }
    }

    private void analyze_lambda(int lambda_idx) {
        Node expr = self.nodes.get(lambda_idx);
        self.push_scope();
        /* Register parameters in scope */
        for (int i = 0; i < expr.items.len; i++) {
            int param_idx = expr.items.get(i);
            Node param = self.nodes.get(param_idx);
            self.collect_generic_instances_from_type(param.n1);
            self.scope_define(param.name, param.n1, "param");
        }
        /* Collect generic instances from return type */
        if (expr.n1 != -1) {
            self.collect_generic_instances_from_type(expr.n1);
        }
        /* Analyze body */
        if (expr.n2 != -1) {
            self.analyze_block(expr.n2);
        }
        self.pop_scope();
    }

    private void analyze_call(int call_idx) {
        Node expr = self.nodes.get(call_idx);
        self.analyze_expr(expr.n1);
        for (int i = 0; i < expr.items.len; i++) {
            self.analyze_expr(expr.items.get(i));
        }

        /* Check if constructor call */
        if (expr.n1 != -1) {
            Node callee = self.nodes.get(expr.n1);
            if (callee.kind == NK_IDENTIFIER && self.class_map.has(callee.name)) {
                int cidx = self.class_map.get(callee.name);
                ClassInfo cls = self.classes.get(cidx);
                if (!cls.has_constructor && expr.items.len > 0) {
                    self.add_error("Class has no constructor", expr.line, expr.col);
                }
            }
        }
    }

    private void analyze_field_access(int fa_idx) {
        Node expr = self.nodes.get(fa_idx);
        self.analyze_expr(expr.n1);

        /* Check access control */
        int obj_type = self.infer_type(expr.n1);
        if (obj_type != -1) {
            Node tn = self.nodes.get(obj_type);
            if (self.class_map.has(tn.name)) {
                int cidx = self.class_map.get(tn.name);
                ClassInfo cls = self.classes.get(cidx);
                self.check_access(cls, expr.name, expr.line, expr.col);
            }
        }

        /* Static call: ClassName.method() */
        if (expr.n1 != -1) {
            Node obj = self.nodes.get(expr.n1);
            if (obj.kind == NK_IDENTIFIER && self.class_map.has(obj.name)) {
                int cidx = self.class_map.get(obj.name);
                ClassInfo cls = self.classes.get(cidx);
                int midx = cls.find_method(expr.name);
                if (midx >= 0) {
                    string maccess = cls.method_access.get(midx);
                    if (!maccess.equals("class")) {
                        self.add_error("Method is not a class method, cannot call statically",
                                       expr.line, expr.col);
                    }
                }
            }
        }
    }

    private void check_access(ClassInfo cls, string member_name, int line, int col) {
        /* Check field access */
        int fidx = cls.find_field(member_name);
        if (fidx >= 0) {
            string access = cls.field_access.get(fidx);
            if (access.equals("private")) {
                if (!self.current_class_name.equals(cls.name)) {
                    self.add_error("Cannot access private field", line, col);
                }
            }
            return;
        }
        /* Check method access */
        int midx = cls.find_method(member_name);
        if (midx >= 0) {
            string access = cls.method_access.get(midx);
            if (access.equals("private")) {
                if (!self.current_class_name.equals(cls.name)) {
                    self.add_error("Cannot access private method", line, col);
                }
            }
        }
    }

    /* ---- Self validation ---- */

    private void validate_self(Node expr) {
        if (self.current_class_name.len() == 0) {
            self.add_error("'self' used outside of a class", expr.line, expr.col);
        } else if (self.current_method_access.equals("class")) {
            self.add_error("'self' cannot be used in a class (static) method",
                           expr.line, expr.col);
        }
    }

    /* ---- Generic instance collection ---- */

    private void collect_generic_instances_from_type(int type_idx) {
        if (type_idx == -1) { return; }
        Node tn = self.nodes.get(type_idx);
        if (tn.kind != NK_TYPE) { return; }

        if (tn.items.len > 0) {
            /* Build mangled name for dedup: e.g. "List_int" or "Map_string_int" */
            var buf = CharBuffer(128);
            self.mangle_type_into(type_idx, buf);
            string key = buf.toString();
            buf.__del__();

            /* Check for duplicate */
            bool found = false;
            for (int i = 0; i < self.generic_instance_keys.len; i++) {
                string existing = self.generic_instance_keys.get(i);
                if (existing.equals(key)) {
                    found = true;
                    break;
                }
            }
            if (!found) {
                self.generic_instance_keys.push(key);
            }

            /* Recurse into generic args */
            for (int i = 0; i < tn.items.len; i++) {
                self.collect_generic_instances_from_type(tn.items.get(i));
            }
        }
    }

    private void collect_tuple_instance(int tuple_idx) {
        Node expr = self.nodes.get(tuple_idx);
        /* Build a Tuple type node from element types */
        Node tt = Node(NK_TYPE, expr.line, expr.col);
        tt.name = "Tuple";
        for (int i = 0; i < expr.items.len; i++) {
            int elem_type = self.infer_type(expr.items.get(i));
            if (elem_type == -1) {
                /* fallback: int */
                Node fb = Node(NK_TYPE, expr.line, expr.col);
                fb.name = "int";
                elem_type = self.nodes.len;
                self.nodes.push(fb);
            }
            tt.items.push(elem_type);
        }
        int tt_idx = self.nodes.len;
        self.nodes.push(tt);
        self.collect_generic_instances_from_type(tt_idx);
    }

    /* Build a mangled name for a type, e.g. List<int> → "List_int" */
    private void mangle_type_into(int type_idx, CharBuffer buf) {
        if (type_idx == -1) { return; }
        Node tn = self.nodes.get(type_idx);
        if (tn.kind != NK_TYPE) { return; }

        /* Write base name */
        for (int i = 0; i < tn.name.len(); i++) {
            char c = tn.name.charAt(i);
            if (c == ' ') {
                buf.push('_');
            } else {
                buf.push(c);
            }
        }

        /* Generic args */
        if (tn.items.len > 0) {
            buf.push('_');
            for (int i = 0; i < tn.items.len; i++) {
                if (i > 0) { buf.push('_'); }
                self.mangle_type_into(tn.items.get(i), buf);
            }
        }

        /* Pointer depth */
        for (int i = 0; i < tn.ival; i++) {
            buf.push('p');
        }
    }

    /* ---- Type inference (simplified) ---- */

    public int infer_type(int expr_idx) {
        if (expr_idx == -1) { return -1; }
        /* Check cached type from analysis phase first */
        if (self.node_types.has(expr_idx)) {
            return self.node_types.get(expr_idx);
        }
        Node expr = self.nodes.get(expr_idx);

        if (expr.kind == NK_INT_LIT) {
            return self.make_simple_type("int", expr.line, expr.col);
        }
        if (expr.kind == NK_FLOAT_LIT) {
            return self.make_simple_type("float", expr.line, expr.col);
        }
        if (expr.kind == NK_STRING_LIT || expr.kind == NK_FSTRING) {
            return self.make_simple_type("string", expr.line, expr.col);
        }
        if (expr.kind == NK_CHAR_LIT) {
            return self.make_simple_type("char", expr.line, expr.col);
        }
        if (expr.kind == NK_BOOL_LIT) {
            return self.make_simple_type("bool", expr.line, expr.col);
        }
        if (expr.kind == NK_NULL_LIT) {
            Node tn = Node(NK_TYPE, expr.line, expr.col);
            tn.name = "void";
            tn.ival = 1;
            int idx = self.nodes.len;
            self.nodes.push(tn);
            return idx;
        }
        if (expr.kind == NK_IDENTIFIER) {
            int result = self.scope_lookup(expr.name);
            if (result != -2) {
                self.node_types.put(expr_idx, result);
                return result;
            }
            return -1;
        }
        if (expr.kind == NK_SELF) {
            if (self.current_class_name.len() > 0) {
                Node tn = Node(NK_TYPE, expr.line, expr.col);
                tn.name = self.current_class_name;
                tn.ival = 1; /* pointer */
                int idx = self.nodes.len;
                self.nodes.push(tn);
                return idx;
            }
            return -1;
        }
        if (expr.kind == NK_FIELD_ACCESS) {
            int obj_type = self.infer_type(expr.n1);
            if (obj_type != -1) {
                Node tn = self.nodes.get(obj_type);
                if (self.class_map.has(tn.name)) {
                    int cidx = self.class_map.get(tn.name);
                    ClassInfo cls = self.classes.get(cidx);
                    int fidx = cls.find_field(expr.name);
                    if (fidx >= 0) {
                        return cls.field_types.get(fidx);
                    }
                    /* Check property */
                    int pidx = cls.find_property(expr.name);
                    if (pidx >= 0) {
                        return cls.prop_types.get(pidx);
                    }
                }
            }
            /* Static method: ClassName.method() — check obj is identifier */
            if (expr.n1 != -1) {
                Node obj = self.nodes.get(expr.n1);
                if (obj.kind == NK_IDENTIFIER && self.class_map.has(obj.name)) {
                    int cidx = self.class_map.get(obj.name);
                    ClassInfo cls = self.classes.get(cidx);
                    int midx = cls.find_method(expr.name);
                    if (midx >= 0) {
                        return cls.method_ret_types.get(midx);
                    }
                }
            }
            return -1;
        }
        if (expr.kind == NK_CALL) {
            if (expr.n1 != -1) {
                Node callee = self.nodes.get(expr.n1);
                if (callee.kind == NK_IDENTIFIER) {
                    /* Constructor call */
                    if (self.class_map.has(callee.name)) {
                        return self.make_simple_type(callee.name, expr.line, expr.col);
                    }
                    /* Function call */
                    if (self.function_table.has(callee.name)) {
                        return self.function_table.get(callee.name);
                    }
                }
                /* Method call: obj.method() */
                if (callee.kind == NK_FIELD_ACCESS) {
                    int obj_type = self.infer_type(callee.n1);
                    if (obj_type != -1) {
                        Node tn = self.nodes.get(obj_type);
                        /* String method */
                        if (tn.name.equals("string") ||
                            (tn.name.equals("char") && tn.ival >= 1)) {
                            return self.string_method_type(callee.name, expr.line, expr.col);
                        }
                        /* Collection method return type */
                        if (tn.name.equals("List") && tn.items.len > 0) {
                            if (callee.name.equals("get") || callee.name.equals("pop")) {
                                return tn.items.get(0);
                            }
                            if (callee.name.equals("slice") || callee.name.equals("filter")) {
                                return obj_type;
                            }
                            if (callee.name.equals("contains") || callee.name.equals("indexOf") ||
                                callee.name.equals("lastIndexOf") || callee.name.equals("any") ||
                                callee.name.equals("all")) {
                                Node rt = Node(NK_TYPE, expr.line, expr.col);
                                if (callee.name.equals("contains") || callee.name.equals("any") ||
                                    callee.name.equals("all")) { rt.name = "bool"; }
                                else { rt.name = "int"; }
                                int ri = self.nodes.len;
                                self.nodes.push(rt);
                                return ri;
                            }
                            if (callee.name.equals("join")) {
                                Node rt = Node(NK_TYPE, expr.line, expr.col);
                                rt.name = "string";
                                int ri = self.nodes.len;
                                self.nodes.push(rt);
                                return ri;
                            }
                        }
                        if (tn.name.equals("Map") && tn.items.len == 2) {
                            if (callee.name.equals("get")) {
                                return tn.items.get(1);
                            }
                            if (callee.name.equals("has")) {
                                Node rt = Node(NK_TYPE, expr.line, expr.col);
                                rt.name = "bool";
                                int ri = self.nodes.len;
                                self.nodes.push(rt);
                                return ri;
                            }
                            if (callee.name.equals("keys") && tn.items.len >= 1) {
                                Node rt = Node(NK_TYPE, expr.line, expr.col);
                                rt.name = "List";
                                rt.items.push(tn.items.get(0));
                                int ri = self.nodes.len;
                                self.nodes.push(rt);
                                return ri;
                            }
                            if (callee.name.equals("values") && tn.items.len >= 2) {
                                Node rt = Node(NK_TYPE, expr.line, expr.col);
                                rt.name = "List";
                                rt.items.push(tn.items.get(1));
                                int ri = self.nodes.len;
                                self.nodes.push(rt);
                                return ri;
                            }
                        }
                        /* Class method */
                        if (self.class_map.has(tn.name)) {
                            int cidx = self.class_map.get(tn.name);
                            ClassInfo cls = self.classes.get(cidx);
                            int midx = cls.find_method(callee.name);
                            if (midx >= 0) {
                                return cls.method_ret_types.get(midx);
                            }
                        }
                    }
                    /* Static method: ClassName.method() */
                    if (callee.n1 != -1) {
                        Node obj = self.nodes.get(callee.n1);
                        if (obj.kind == NK_IDENTIFIER && self.class_map.has(obj.name)) {
                            int cidx = self.class_map.get(obj.name);
                            ClassInfo cls = self.classes.get(cidx);
                            int midx = cls.find_method(callee.name);
                            if (midx >= 0) {
                                return cls.method_ret_types.get(midx);
                            }
                        }
                    }
                }
            }
            return -1;
        }
        if (expr.kind == NK_NEW) {
            if (expr.n1 != -1) {
                Node type_node = self.nodes.get(expr.n1);
                Node tn = Node(NK_TYPE, expr.line, expr.col);
                tn.name = type_node.name;
                tn.ival = 1; /* pointer */
                /* Copy generic args */
                for (int i = 0; i < type_node.items.len; i++) {
                    tn.items.push(type_node.items.get(i));
                }
                int idx = self.nodes.len;
                self.nodes.push(tn);
                return idx;
            }
            return -1;
        }
        if (expr.kind == NK_INDEX) {
            int obj_type = self.infer_type(expr.n1);
            if (obj_type != -1) {
                Node tn = self.nodes.get(obj_type);
                if ((tn.name.equals("List") || tn.name.equals("Array")) && tn.items.len > 0) {
                    return tn.items.get(0);
                }
            }
            return -1;
        }
        if (expr.kind == NK_BINARY) {
            /* Comparison/logical → bool */
            if (expr.op.equals("==") || expr.op.equals("!=") ||
                expr.op.equals("<") || expr.op.equals(">") ||
                expr.op.equals("<=") || expr.op.equals(">=") ||
                expr.op.equals("&&") || expr.op.equals("||")) {
                return self.make_simple_type("bool", expr.line, expr.col);
            }
            int left_type = self.infer_type(expr.n1);
            int right_type = self.infer_type(expr.n2);
            if (left_type != -1 && right_type != -1) {
                Node lt = self.nodes.get(left_type);
                Node rt = self.nodes.get(right_type);
                if (lt.name.equals("float") || lt.name.equals("double") ||
                    rt.name.equals("float") || rt.name.equals("double")) {
                    return self.make_simple_type("float", expr.line, expr.col);
                }
                if (lt.name.equals("int") && rt.name.equals("int")) {
                    return self.make_simple_type("int", expr.line, expr.col);
                }
            }
            return left_type;
        }
        if (expr.kind == NK_CAST) {
            return expr.n1; /* target type */
        }
        if (expr.kind == NK_UNARY) {
            return self.infer_type(expr.n1);
        }
        if (expr.kind == NK_TERNARY) {
            return self.infer_type(expr.n2);
        }
        if (expr.kind == NK_ASSIGN) {
            return self.infer_type(expr.n1);
        }
        if (expr.kind == NK_LIST_LIT) {
            if (expr.items.len > 0) {
                int elem_type = self.infer_type(expr.items.get(0));
                if (elem_type != -1) {
                    Node tn = Node(NK_TYPE, expr.line, expr.col);
                    tn.name = "List";
                    tn.items.push(elem_type);
                    int idx = self.nodes.len;
                    self.nodes.push(tn);
                    return idx;
                }
            }
            /* Default: List<int> */
            Node fb_elem = Node(NK_TYPE, expr.line, expr.col);
            fb_elem.name = "int";
            int fb_elem_idx = self.nodes.len;
            self.nodes.push(fb_elem);
            Node tn = Node(NK_TYPE, expr.line, expr.col);
            tn.name = "List";
            tn.items.push(fb_elem_idx);
            int idx = self.nodes.len;
            self.nodes.push(tn);
            return idx;
        }
        if (expr.kind == NK_MAP_LIT) {
            if (expr.items.len > 0) {
                int key_type = self.infer_type(expr.items.get(0));
                int val_type = self.infer_type(expr.items2.get(0));
                if (key_type != -1 && val_type != -1) {
                    Node tn = Node(NK_TYPE, expr.line, expr.col);
                    tn.name = "Map";
                    tn.items.push(key_type);
                    tn.items.push(val_type);
                    int idx = self.nodes.len;
                    self.nodes.push(tn);
                    return idx;
                }
            }
            /* Default: Map<string,int> */
            Node kt = Node(NK_TYPE, expr.line, expr.col);
            kt.name = "string";
            int kt_idx = self.nodes.len;
            self.nodes.push(kt);
            Node vt = Node(NK_TYPE, expr.line, expr.col);
            vt.name = "int";
            int vt_idx = self.nodes.len;
            self.nodes.push(vt);
            Node tn = Node(NK_TYPE, expr.line, expr.col);
            tn.name = "Map";
            tn.items.push(kt_idx);
            tn.items.push(vt_idx);
            int idx = self.nodes.len;
            self.nodes.push(tn);
            return idx;
        }
        if (expr.kind == NK_LAMBDA) {
            /* Create __fn_ptr type: items[0]=ret_type, items[1..]=param_types */
            Node tn = Node(NK_TYPE, expr.line, expr.col);
            tn.name = "__fn_ptr";
            /* Return type */
            int ret_type = -1;
            if (expr.n1 != -1) {
                ret_type = expr.n1;
            } else {
                /* Infer from body: find first return statement */
                if (expr.n2 != -1) {
                    Node body = self.nodes.get(expr.n2);
                    for (int i = 0; i < body.items.len; i++) {
                        Node s = self.nodes.get(body.items.get(i));
                        if (s.kind == NK_RETURN && s.n1 != -1) {
                            ret_type = self.infer_type(s.n1);
                            break;
                        }
                    }
                }
                if (ret_type == -1) {
                    ret_type = self.make_simple_type("int", expr.line, expr.col);
                }
            }
            tn.items.push(ret_type);
            /* Parameter types */
            for (int i = 0; i < expr.items.len; i++) {
                Node param = self.nodes.get(expr.items.get(i));
                tn.items.push(param.n1);
            }
            int idx = self.nodes.len;
            self.nodes.push(tn);
            return idx;
        }
        if (expr.kind == NK_TUPLE_LIT) {
            Node tn = Node(NK_TYPE, expr.line, expr.col);
            tn.name = "Tuple";
            for (int i = 0; i < expr.items.len; i++) {
                int et = self.infer_type(expr.items.get(i));
                if (et == -1) {
                    et = self.make_simple_type("int", expr.line, expr.col);
                }
                tn.items.push(et);
            }
            int idx = self.nodes.len;
            self.nodes.push(tn);
            return idx;
        }

        return -1;
    }

    /* ---- Helpers ---- */

    private int make_simple_type(string name, int line, int col) {
        Node tn = Node(NK_TYPE, line, col);
        tn.name = name;
        int idx = self.nodes.len;
        self.nodes.push(tn);
        return idx;
    }

    private int string_method_type(string method_name, int line, int col) {
        if (method_name.equals("len") || method_name.equals("byteLen") ||
            method_name.equals("charLen") || method_name.equals("indexOf")) {
            return self.make_simple_type("int", line, col);
        }
        if (method_name.equals("contains") || method_name.equals("startsWith") ||
            method_name.equals("endsWith") || method_name.equals("equals")) {
            return self.make_simple_type("bool", line, col);
        }
        if (method_name.equals("charAt")) {
            return self.make_simple_type("char", line, col);
        }
        if (method_name.equals("substring") || method_name.equals("trim") ||
            method_name.equals("toUpper") || method_name.equals("toLower")) {
            return self.make_simple_type("string", line, col);
        }
        return -1;
    }

    private int get_element_type(int iter_type_idx, int line, int col) {
        if (iter_type_idx == -1) { return -1; }
        Node tn = self.nodes.get(iter_type_idx);

        if ((tn.name.equals("List") || tn.name.equals("Array")) && tn.items.len > 0) {
            return tn.items.get(0);
        }
        return -1;
    }

    /* ---- Public accessors for codegen ---- */

    public bool has_class(string name) {
        return self.class_map.has(name);
    }

    public ClassInfo get_class(string name) {
        int idx = self.class_map.get(name);
        return self.classes.get(idx);
    }

    public List<string> get_generic_keys() {
        return self.generic_instance_keys;
    }

    public bool has_function(string name) {
        return self.function_table.has(name);
    }

    public int get_function_ret_type(string name) {
        return self.function_table.get(name);
    }
}
