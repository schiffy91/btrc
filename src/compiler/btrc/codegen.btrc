/* btrc self-hosted compiler — C Code Generator
 *
 * Transforms an analyzed AST into C source code.
 * Writes output to a File object.
 */

class CodeGen {
    private File out;
    private Analyzer analyzer;
    private int indent;
    private string current_class;
    private bool in_constructor;
    /* Generic instances: collected from arena scan */
    private List<int> generic_types;
    private List<string> generic_keys;
    private Map<string, int> generic_key_set; /* O(1) dedup check */
    /* Lambda support */
    private int lambda_counter;
    private List<string> lambda_defs;
    /* F-string counter for heap-allocated f-string temporaries */
    private int fstr_counter;
    /* Track globals/enums already emitted before lambdas */
    private List<int> emitted_globals;

    public CodeGen(List<Node> nodes, Analyzer analyzer, File out) {
        self.out = out;
        self.analyzer = analyzer;
        self.analyzer.nodes = nodes;
        self.indent = 0;
        self.current_class = "";
        self.in_constructor = false;
        self.generic_types = [];
        self.generic_keys = [];
        self.generic_key_set = {};
        self.lambda_counter = 0;
        self.lambda_defs = [];
        self.fstr_counter = 0;
        self.emitted_globals = [];
    }

    /* ---- Main entry point ---- */

    public void generate(int program_idx) {
        self.collect_generic_instances();
        self.prescan_lambdas(program_idx);
        self.emit_header();
        self.emit_preprocessor_directives(program_idx);
        self.emit_string_helpers();
        self.emit_try_catch_runtime();
        self.emit_forward_declarations(program_idx);
        self.emit_generic_struct_typedefs();
        self.emit_struct_definitions(program_idx);
        self.emit_destroy_forward_decls(program_idx);
        self.emit_generic_function_bodies();
        /* Emit globals/enums before lambdas so lambdas can reference them */
        self.emit_globals_and_enums(program_idx);
        /* Emit lambda definitions */
        for (int i = 0; i < self.lambda_defs.len; i++) {
            self.out.write(f"{self.lambda_defs.get(i)}");
        }
        self.emit_declarations(program_idx);
    }

    /* ---- Output helpers ---- */

    private void indent_out() {
        for (int i = 0; i < self.indent; i++) {
            self.out.write("    ");
        }
    }

    private void emit(string text) {
        self.indent_out();
        self.out.writeLine(f"{text}");
    }

    private void emit_raw(string text) {
        self.out.writeLine(f"{text}");
    }

    private void emit_blank() {
        self.out.writeLine("");
    }

    /* ---- Lambda pre-scanning ---- */

    private void prescan_lambdas(int program_idx) {
        /* Walk entire AST to find all NK_LAMBDA nodes */
        for (int i = 0; i < self.analyzer.nodes.len; i++) {
            Node n = self.analyzer.nodes.get(i);
            if (n.kind == NK_LAMBDA) {
                self.register_lambda(i);
            }
        }
    }

    private void register_lambda(int lambda_idx) {
        self.lambda_counter++;
        Node expr = self.analyzer.nodes.get(lambda_idx);
        string lambda_name = f"__btrc_lambda_{self.lambda_counter}";
        /* Store the C function name in the node's sval field */
        expr.sval = lambda_name;
        self.analyzer.nodes.set(lambda_idx, expr);

        /* Determine return type */
        string ret_type = "int";
        if (expr.n1 != -1) {
            ret_type = self.type_to_c(expr.n1);
        } else {
            /* Infer from body: find first return statement */
            if (expr.n2 != -1) {
                Node body = self.analyzer.nodes.get(expr.n2);
                for (int i = 0; i < body.items.len; i++) {
                    Node s = self.analyzer.nodes.get(body.items.get(i));
                    if (s.kind == NK_RETURN && s.n1 != -1) {
                        int rt = self.analyzer.infer_type(s.n1);
                        if (rt != -1) {
                            ret_type = self.type_to_c(rt);
                        }
                        break;
                    }
                }
            }
        }

        /* Build parameter list */
        var params_buf = CharBuffer(256);
        if (expr.items.len == 0) {
            params_buf.appendStr("void");
        } else {
            for (int i = 0; i < expr.items.len; i++) {
                if (i > 0) { params_buf.appendStr(", "); }
                Node param = self.analyzer.nodes.get(expr.items.get(i));
                string ptype = self.type_to_c(param.n1);
                params_buf.appendStr(ptype);
                params_buf.push(' ');
                params_buf.appendStr(param.name);
            }
        }
        string params_str = params_buf.toString();
        params_buf.__del__();

        /* Generate function body by redirecting output to a temp file */
        File saved_out = self.out;
        int saved_indent = self.indent;
        FILE* mem = tmpfile();
        var mem_file = File("", "w");
        mem_file.setHandle(mem);
        self.out = mem_file;
        self.indent = 1;
        if (expr.n2 != -1) {
            self.emit_block_contents(expr.n2);
        }
        mem_file.flush();
        long body_len = ftell(mem);
        rewind(mem);
        char* body_buf = (char*)malloc(body_len + 1);
        fread(body_buf, 1, body_len, mem);
        body_buf[body_len] = '\0';
        fclose(mem);
        self.out = saved_out;
        self.indent = saved_indent;

        /* Build the full lambda function string */
        string header = "static " + ret_type + " " + lambda_name + "(" + params_str + ") {\n";
        var def_buf = CharBuffer(1024);
        def_buf.appendStr(header);
        if (body_buf != NULL) {
            def_buf.appendStr(body_buf);
            free(body_buf);
        }
        def_buf.appendStr("}\n\n");
        self.lambda_defs.push(def_buf.toString());
        def_buf.__del__();
    }

    /* ---- Collect generic instances from arena ---- */

    private void add_generic_type(int idx) {
        string key = self.mangle_type(idx);
        if (self.generic_key_set.has(key)) { return; }
        self.generic_key_set.put(key, 1);
        self.generic_keys.push(key);
        self.generic_types.push(idx);
    }

    private void collect_generic_instances() {
        for (int i = 0; i < self.analyzer.nodes.len; i++) {
            Node n = self.analyzer.nodes.get(i);
            if (n.kind == NK_TYPE && n.items.len > 0) {
                self.add_generic_type(i);
            }
        }
        /* For every Map<K,V>, ensure List<K> and List<V> also exist.
           Map.keys() and Map.values() return these list types. */
        int count = self.generic_types.len;
        for (int i = 0; i < count; i++) {
            int tidx = self.generic_types.get(i);
            Node tn = self.analyzer.nodes.get(tidx);
            if (tn.name.equals("Map") && tn.items.len == 2) {
                /* Create synthetic List<K> and List<V> type nodes if missing */
                int key_type_idx = tn.items.get(0);
                int val_type_idx = tn.items.get(1);
                /* Build List<K> type node */
                Node lk = Node(NK_TYPE, 0, 0);
                lk.name = "List";
                lk.items.push(key_type_idx);
                int lk_idx = self.analyzer.nodes.len;
                self.analyzer.nodes.push(lk);
                self.add_generic_type(lk_idx);
                /* Build List<V> type node */
                Node lv = Node(NK_TYPE, 0, 0);
                lv.name = "List";
                lv.items.push(val_type_idx);
                int lv_idx = self.analyzer.nodes.len;
                self.analyzer.nodes.push(lv);
                self.add_generic_type(lv_idx);
            }
        }
    }

    /* ---- Header ---- */

    private void emit_header() {
        self.emit("/* Generated by btrc */");
        self.emit("#include <stdio.h>");
        self.emit("#include <stdlib.h>");
        self.emit("#include <stdbool.h>");
        self.emit("#include <string.h>");
        self.emit("#include <ctype.h>");
        self.emit("#include <math.h>");
        self.emit("#include <setjmp.h>");
        self.emit("#include <assert.h>");
        self.emit_blank();
    }

    /* Emit user preprocessor directives (#include <assert.h>, etc.) right after standard headers */
    private void emit_preprocessor_directives(int prog_idx) {
        Node prog = self.analyzer.nodes.get(prog_idx);
        for (int i = 0; i < prog.items.len; i++) {
            int d = prog.items.get(i);
            Node decl = self.analyzer.nodes.get(d);
            if (decl.kind == NK_PREPROCESSOR) {
                self.emit_raw(decl.sval);
            }
        }
    }

    private void emit_string_helpers() {
        self.emit("/* btrc string helper functions */");
        self.emit("static inline char* __btrc_substring(const char* s, int start, int len) {");
        self.emit("    char* result = (char*)malloc(len + 1);");
        self.emit("    strncpy(result, s + start, len);");
        self.emit("    result[len] = '\\0';");
        self.emit("    return result;");
        self.emit("}");
        self.emit_blank();
        self.emit("static inline char* __btrc_trim(const char* s) {");
        self.emit("    while (*s && isspace((unsigned char)*s)) s++;");
        self.emit("    if (*s == '\\0') { char* r = (char*)malloc(1); r[0]='\\0'; return r; }");
        self.emit("    const char* end = s + strlen(s) - 1;");
        self.emit("    while (end > s && isspace((unsigned char)*end)) end--;");
        self.emit("    int len = (int)(end - s + 1);");
        self.emit("    char* result = (char*)malloc(len + 1);");
        self.emit("    strncpy(result, s, len);");
        self.emit("    result[len] = '\\0';");
        self.emit("    return result;");
        self.emit("}");
        self.emit_blank();
        self.emit("static inline char* __btrc_toUpper(const char* s) {");
        self.emit("    int len = (int)strlen(s);");
        self.emit("    char* result = (char*)malloc(len + 1);");
        self.emit("    for (int i = 0; i < len; i++) result[i] = (char)toupper((unsigned char)s[i]);");
        self.emit("    result[len] = '\\0';");
        self.emit("    return result;");
        self.emit("}");
        self.emit_blank();
        self.emit("static inline char* __btrc_toLower(const char* s) {");
        self.emit("    int len = (int)strlen(s);");
        self.emit("    char* result = (char*)malloc(len + 1);");
        self.emit("    for (int i = 0; i < len; i++) result[i] = (char)tolower((unsigned char)s[i]);");
        self.emit("    result[len] = '\\0';");
        self.emit("    return result;");
        self.emit("}");
        self.emit_blank();
        self.emit("static inline int __btrc_utf8_charlen(const char* s) {");
        self.emit("    int count = 0;");
        self.emit("    while (*s) { if ((*s & 0xC0) != 0x80) count++; s++; }");
        self.emit("    return count;");
        self.emit("}");
        self.emit_blank();
        self.emit("static inline int __btrc_indexOf(const char* s, const char* sub) {");
        self.emit("    char* p = strstr(s, sub);");
        self.emit("    return p ? (int)(p - s) : -1;");
        self.emit("}");
        self.emit_blank();
        self.emit("static inline char* __btrc_strcat(const char* a, const char* b) {");
        self.emit("    int la = (int)strlen(a), lb = (int)strlen(b);");
        self.emit("    char* r = (char*)malloc(la + lb + 1);");
        self.emit("    memcpy(r, a, la);");
        self.emit("    memcpy(r + la, b, lb + 1);");
        self.emit("    return r;");
        self.emit("}");
        self.emit_blank();
        self.emit("static inline int __btrc_lastIndexOf(const char* s, const char* sub) {");
        self.emit("    int slen = (int)strlen(s); int sublen = (int)strlen(sub);");
        self.emit("    if (sublen == 0) return slen;");
        self.emit("    for (int i = slen - sublen; i >= 0; i--) { if (strncmp(s + i, sub, sublen) == 0) return i; }");
        self.emit("    return -1;");
        self.emit("}");
        self.emit_blank();
        self.emit("static inline char* __btrc_replace(const char* s, const char* old, const char* rep) {");
        self.emit("    int slen = (int)strlen(s), oldlen = (int)strlen(old), replen = (int)strlen(rep);");
        self.emit("    if (oldlen == 0) return strdup(s);");
        self.emit("    int cap = slen * 2 + 1; char* result = (char*)malloc(cap); int rlen = 0, i = 0;");
        self.emit("    while (i < slen) {");
        self.emit("        if (i + oldlen <= slen && strncmp(s + i, old, oldlen) == 0) {");
        self.emit("            while (rlen + replen >= cap) { cap *= 2; result = (char*)realloc(result, cap); }");
        self.emit("            memcpy(result + rlen, rep, replen); rlen += replen; i += oldlen;");
        self.emit("        } else { if (rlen + 1 >= cap) { cap *= 2; result = (char*)realloc(result, cap); } result[rlen++] = s[i++]; }");
        self.emit("    }");
        self.emit("    result[rlen] = '\\0'; return result;");
        self.emit("}");
        self.emit_blank();
        self.emit("static inline char** __btrc_split(const char* s, const char* delim) {");
        self.emit("    int cap = 8; char** result = (char**)malloc(sizeof(char*) * cap); int count = 0; int dlen = (int)strlen(delim); const char* p = s;");
        self.emit("    while (*p) { const char* found = strstr(p, delim); int seglen = found ? (int)(found - p) : (int)strlen(p);");
        self.emit("        if (count + 2 > cap) { cap *= 2; result = (char**)realloc(result, sizeof(char*) * cap); }");
        self.emit("        result[count] = (char*)malloc(seglen + 1); memcpy(result[count], p, seglen); result[count][seglen] = '\\0'; count++;");
        self.emit("        if (!found) break; p = found + dlen; }");
        self.emit("    result[count] = NULL; return result;");
        self.emit("}");
        self.emit_blank();
        self.emit("static inline char* __btrc_repeat(const char* s, int count) {");
        self.emit("    int slen = (int)strlen(s); char* result = (char*)malloc(slen * count + 1); result[0] = '\\0';");
        self.emit("    for (int i = 0; i < count; i++) memcpy(result + i * slen, s, slen);");
        self.emit("    result[slen * count] = '\\0'; return result;");
        self.emit("}");
        self.emit_blank();
        self.emit("static inline char* __btrc_capitalize(const char* s) {");
        self.emit("    int len = (int)strlen(s); char* r = (char*)malloc(len + 1);");
        self.emit("    for (int i = 0; i < len; i++) r[i] = tolower((unsigned char)s[i]);");
        self.emit("    if (len > 0) r[0] = toupper((unsigned char)r[0]); r[len] = '\\0'; return r;");
        self.emit("}");
        self.emit_blank();
        self.emit("static inline char* __btrc_title(const char* s) {");
        self.emit("    int len = (int)strlen(s); char* r = (char*)malloc(len + 1); int cap_next = 1;");
        self.emit("    for (int i = 0; i < len; i++) {");
        self.emit("        if (isspace((unsigned char)s[i])) { r[i] = s[i]; cap_next = 1; }");
        self.emit("        else if (cap_next) { r[i] = toupper((unsigned char)s[i]); cap_next = 0; }");
        self.emit("        else { r[i] = tolower((unsigned char)s[i]); }");
        self.emit("    }");
        self.emit("    r[len] = '\\0'; return r;");
        self.emit("}");
        self.emit_blank();
        self.emit("static inline char* __btrc_swapCase(const char* s) {");
        self.emit("    int len = (int)strlen(s); char* r = (char*)malloc(len + 1);");
        self.emit("    for (int i = 0; i < len; i++) {");
        self.emit("        if (isupper((unsigned char)s[i])) r[i] = tolower((unsigned char)s[i]);");
        self.emit("        else if (islower((unsigned char)s[i])) r[i] = toupper((unsigned char)s[i]);");
        self.emit("        else r[i] = s[i];");
        self.emit("    }");
        self.emit("    r[len] = '\\0'; return r;");
        self.emit("}");
        self.emit_blank();
        self.emit("static inline char* __btrc_padLeft(const char* s, int width, char fill) {");
        self.emit("    int len = (int)strlen(s);");
        self.emit("    if (len >= width) { char* r = (char*)malloc(len + 1); strcpy(r, s); return r; }");
        self.emit("    char* r = (char*)malloc(width + 1); int pad = width - len;");
        self.emit("    memset(r, fill, pad); memcpy(r + pad, s, len); r[width] = '\\0'; return r;");
        self.emit("}");
        self.emit_blank();
        self.emit("static inline char* __btrc_padRight(const char* s, int width, char fill) {");
        self.emit("    int len = (int)strlen(s);");
        self.emit("    if (len >= width) { char* r = (char*)malloc(len + 1); strcpy(r, s); return r; }");
        self.emit("    char* r = (char*)malloc(width + 1); memcpy(r, s, len);");
        self.emit("    memset(r + len, fill, width - len); r[width] = '\\0'; return r;");
        self.emit("}");
        self.emit_blank();
        self.emit("static inline char* __btrc_center(const char* s, int width, char fill) {");
        self.emit("    int len = (int)strlen(s);");
        self.emit("    if (len >= width) { char* r = (char*)malloc(len + 1); strcpy(r, s); return r; }");
        self.emit("    char* r = (char*)malloc(width + 1); int left = (width - len) / 2;");
        self.emit("    memset(r, fill, left); memcpy(r + left, s, len);");
        self.emit("    memset(r + left + len, fill, width - len - left); r[width] = '\\0'; return r;");
        self.emit("}");
        self.emit_blank();
        self.emit("static inline char* __btrc_lstrip(const char* s) {");
        self.emit("    while (*s && isspace((unsigned char)*s)) s++;");
        self.emit("    char* r = (char*)malloc(strlen(s) + 1); strcpy(r, s); return r;");
        self.emit("}");
        self.emit_blank();
        self.emit("static inline char* __btrc_rstrip(const char* s) {");
        self.emit("    int len = (int)strlen(s);");
        self.emit("    while (len > 0 && isspace((unsigned char)s[len - 1])) len--;");
        self.emit("    char* r = (char*)malloc(len + 1); memcpy(r, s, len); r[len] = '\\0'; return r;");
        self.emit("}");
        self.emit_blank();
        self.emit("static inline int __btrc_count(const char* s, const char* sub) {");
        self.emit("    int count = 0, sublen = (int)strlen(sub); if (sublen == 0) return 0;");
        self.emit("    const char* p = s; while ((p = strstr(p, sub)) != NULL) { count++; p += sublen; }");
        self.emit("    return count;");
        self.emit("}");
        self.emit_blank();
        self.emit("static inline int __btrc_find(const char* s, const char* sub, int start) {");
        self.emit("    int len = (int)strlen(s); if (start < 0 || start >= len) return -1;");
        self.emit("    const char* found = strstr(s + start, sub); if (!found) return -1;");
        self.emit("    return (int)(found - s);");
        self.emit("}");
        self.emit_blank();
        self.emit("static inline char* __btrc_fromInt(int n) {");
        self.emit("    char* r = (char*)malloc(21); snprintf(r, 21, \"%d\", n); return r;");
        self.emit("}");
        self.emit_blank();
        self.emit("static inline char* __btrc_fromFloat(float f) {");
        self.emit("    char* r = (char*)malloc(32); snprintf(r, 32, \"%g\", (double)f); return r;");
        self.emit("}");
        self.emit_blank();
        self.emit("static inline bool __btrc_isDigitStr(const char* s) {");
        self.emit("    if (!*s) return false; for (; *s; s++) if (!isdigit((unsigned char)*s)) return false; return true;");
        self.emit("}");
        self.emit_blank();
        self.emit("static inline bool __btrc_isAlphaStr(const char* s) {");
        self.emit("    if (!*s) return false; for (; *s; s++) if (!isalpha((unsigned char)*s)) return false; return true;");
        self.emit("}");
        self.emit_blank();
        self.emit("static inline bool __btrc_isBlank(const char* s) {");
        self.emit("    for (; *s; s++) if (!isspace((unsigned char)*s)) return false; return true;");
        self.emit("}");
        self.emit_blank();
    }

    private void emit_try_catch_runtime() {
        self.emit("/* btrc try/catch runtime */");
        self.emit("#define __BTRC_TRY_STACK_SIZE 64");
        self.emit("static jmp_buf __btrc_try_stack[__BTRC_TRY_STACK_SIZE];");
        self.emit("static int __btrc_try_top = -1;");
        self.emit("static char __btrc_error_msg[1024] = \"\";");
        self.emit_blank();
        self.emit("static inline void __btrc_throw(const char* msg) {");
        self.emit("    if (__btrc_try_top < 0) {");
        self.emit("        fprintf(stderr, \"Unhandled exception: %s\\n\", msg);");
        self.emit("        exit(1);");
        self.emit("    }");
        self.emit("    strncpy(__btrc_error_msg, msg, 1023);");
        self.emit("    __btrc_error_msg[1023] = '\\0';");
        self.emit("    longjmp(__btrc_try_stack[__btrc_try_top--], 1);");
        self.emit("}");
        self.emit_blank();
    }

    /* ---- Forward declarations ---- */

    private void emit_forward_declarations(int prog_idx) {
        Node prog = self.analyzer.nodes.get(prog_idx);
        for (int i = 0; i < prog.items.len; i++) {
            int d = prog.items.get(i);
            Node decl = self.analyzer.nodes.get(d);
            if (decl.kind == NK_CLASS_DECL && decl.items2.len == 0) {
                self.indent_out();
                self.out.writeLine(f"typedef struct {decl.name} {decl.name};");
            }
        }
        self.emit_blank();
    }

    /* ---- Generic struct typedefs ---- */

    private void emit_generic_struct_typedefs() {
        /* Emit List/Array/Tuple structs first, then Map (Map keys/values depend on List) */
        for (int i = 0; i < self.generic_types.len; i++) {
            int tidx = self.generic_types.get(i);
            Node tn = self.analyzer.nodes.get(tidx);
            if (tn.name.equals("List") && tn.items.len == 1) {
                string mangled = self.mangle_type(tn.items.get(0));
                string c_type = self.type_to_c(tn.items.get(0));
                self.emit_list_struct(c_type, mangled);
            } else if (tn.name.equals("Array") && tn.items.len == 1) {
                string mangled = self.mangle_type(tn.items.get(0));
                string c_type = self.type_to_c(tn.items.get(0));
                self.emit_array_struct(c_type, mangled);
            } else if (tn.name.equals("Tuple") && tn.items.len > 0) {
                self.emit_tuple_struct(tidx);
            }
        }
        for (int i = 0; i < self.generic_types.len; i++) {
            int tidx = self.generic_types.get(i);
            Node tn = self.analyzer.nodes.get(tidx);
            if (tn.name.equals("Map") && tn.items.len == 2) {
                string km = self.mangle_type(tn.items.get(0));
                string vm = self.mangle_type(tn.items.get(1));
                string kt = self.type_to_c(tn.items.get(0));
                string vt = self.type_to_c(tn.items.get(1));
                self.emit_map_struct(kt, vt, km, vm);
            }
        }
    }

    private void emit_list_struct(string c_type, string mangled) {
        string name = f"btrc_List_{mangled}";
        self.out.writeLine("typedef struct {");
        self.out.writeLine(f"    {c_type}* data;");
        self.out.writeLine("    int len;");
        self.out.writeLine("    int cap;");
        self.out.writeLine(f"}} {name};");
        self.emit_blank();
    }

    private void emit_array_struct(string c_type, string mangled) {
        string name = f"btrc_Array_{mangled}";
        self.out.writeLine("typedef struct {");
        self.out.writeLine(f"    {c_type}* data;");
        self.out.writeLine("    int len;");
        self.out.writeLine(f"}} {name};");
        self.emit_blank();
    }

    private void emit_map_struct(string kt, string vt, string km, string vm) {
        string name = f"btrc_Map_{km}_{vm}";
        self.out.writeLine(f"typedef struct {{ {kt} key; {vt} value; bool occupied; }} {name}_entry;");
        self.out.writeLine("typedef struct {");
        self.out.writeLine(f"    {name}_entry* buckets;");
        self.out.writeLine("    int cap;");
        self.out.writeLine("    int len;");
        self.out.writeLine(f"}} {name};");
        self.emit_blank();
    }

    private void emit_tuple_struct(int type_idx) {
        Node tn = self.analyzer.nodes.get(type_idx);
        string mangled = self.mangle_type(type_idx);
        /* Strip leading "Tuple_" prefix since mangle includes it */
        self.out.writeLine("typedef struct {");
        for (int i = 0; i < tn.items.len; i++) {
            string ct = self.type_to_c(tn.items.get(i));
            self.out.writeLine(f"    {ct} _{i};");
        }
        self.out.writeLine(f"}} btrc_{mangled};");
        self.emit_blank();
    }

    /* ---- Class struct bodies ---- */

    private void emit_struct_definitions(int prog_idx) {
        Node prog = self.analyzer.nodes.get(prog_idx);
        for (int i = 0; i < prog.items.len; i++) {
            int d = prog.items.get(i);
            Node decl = self.analyzer.nodes.get(d);
            if (decl.kind == NK_CLASS_DECL && decl.items2.len == 0) {
                self.emit_class_struct(d);
            }
        }
    }

    private void emit_class_struct(int class_idx) {
        Node decl = self.analyzer.nodes.get(class_idx);
        self.out.writeLine(f"struct {decl.name} {{");
        /* Inherited fields from parent */
        if (decl.name2.len() > 0 && self.analyzer.has_class(decl.name2)) {
            ClassInfo parent = self.analyzer.get_class(decl.name2);
            /* Collect child field names for override check */
            for (int i = 0; i < parent.field_names.len; i++) {
                string fname = parent.field_names.get(i);
                bool overridden = false;
                for (int j = 0; j < decl.items.len; j++) {
                    Node m = self.analyzer.nodes.get(decl.items.get(j));
                    if (m.kind == NK_FIELD_DECL && m.name.equals(fname)) {
                        overridden = true;
                        break;
                    }
                }
                if (!overridden) {
                    string ct = self.type_to_c(parent.field_types.get(i));
                    self.out.writeLine(f"    {ct} {fname};");
                }
            }
        }
        /* Own fields */
        for (int i = 0; i < decl.items.len; i++) {
            Node m = self.analyzer.nodes.get(decl.items.get(i));
            if (m.kind == NK_FIELD_DECL) {
                string ct = self.type_to_c(m.n1);
                self.out.writeLine(f"    {ct} {m.name};");
            } else if (m.kind == NK_PROPERTY_DECL) {
                /* Auto-properties get a backing field _name */
                bool auto_get = m.flag1 && m.n2 == -1;
                bool auto_set = m.flag2 && m.n3 == -1;
                if (auto_get || auto_set) {
                    string ct = self.type_to_c(m.n1);
                    self.out.writeLine(f"    {ct} _{m.name};");
                }
            }
        }
        self.out.writeLine("};");
        self.emit_blank();
    }

    /* ---- Destroy forward declarations ---- */

    private void emit_destroy_forward_decls(int prog_idx) {
        Node prog = self.analyzer.nodes.get(prog_idx);
        for (int i = 0; i < prog.items.len; i++) {
            int d = prog.items.get(i);
            Node decl = self.analyzer.nodes.get(d);
            if (decl.kind == NK_CLASS_DECL && decl.items2.len == 0) {
                self.out.writeLine(f"void {decl.name}_destroy({decl.name}* self);");
            }
        }
        self.emit_blank();
    }

    /* ---- Generic function bodies ---- */

    private void emit_generic_function_bodies() {
        /* Emit all List functions first, then Maps (Maps depend on List for keys/values) */
        for (int i = 0; i < self.generic_types.len; i++) {
            int tidx = self.generic_types.get(i);
            Node tn = self.analyzer.nodes.get(tidx);
            if (tn.name.equals("List") && tn.items.len == 1) {
                string mangled = self.mangle_type(tn.items.get(0));
                string c_type = self.type_to_c(tn.items.get(0));
                self.emit_list_functions(c_type, mangled);
            }
        }
        for (int i = 0; i < self.generic_types.len; i++) {
            int tidx = self.generic_types.get(i);
            Node tn = self.analyzer.nodes.get(tidx);
            if (tn.name.equals("Map") && tn.items.len == 2) {
                string km = self.mangle_type(tn.items.get(0));
                string vm = self.mangle_type(tn.items.get(1));
                string kt = self.type_to_c(tn.items.get(0));
                string vt = self.type_to_c(tn.items.get(1));
                self.emit_map_functions(kt, vt, km, vm);
            }
        }
    }

    private void emit_list_functions(string c_type, string mangled) {
        string n = f"btrc_List_{mangled}";
        /* new */
        self.out.writeLine(f"static inline {n} {n}_new() {{");
        self.out.writeLine(f"    return ({n}){{NULL, 0, 0}};");
        self.out.writeLine("}");
        self.emit_blank();
        /* push */
        self.out.writeLine(f"static inline void {n}_push({n}* l, {c_type} val) {{");
        self.out.writeLine("    if (l->len >= l->cap) {");
        self.out.writeLine("        l->cap = l->cap ? l->cap * 2 : 4;");
        self.out.writeLine(f"        l->data = ({c_type}*)realloc(l->data, sizeof({c_type}) * l->cap);");
        self.out.writeLine("    }");
        self.out.writeLine("    l->data[l->len++] = val;");
        self.out.writeLine("}");
        self.emit_blank();
        /* get */
        self.out.writeLine(f"static inline {c_type} {n}_get({n}* l, int i) {{");
        self.out.writeLine("    return l->data[i];");
        self.out.writeLine("}");
        self.emit_blank();
        /* set */
        self.out.writeLine(f"static inline void {n}_set({n}* l, int i, {c_type} val) {{");
        self.out.writeLine("    l->data[i] = val;");
        self.out.writeLine("}");
        self.emit_blank();
        /* free */
        self.out.writeLine(f"static inline void {n}_free({n}* l) {{");
        self.out.writeLine("    free(l->data);");
        self.out.writeLine("    l->data = NULL; l->len = 0; l->cap = 0;");
        self.out.writeLine("}");
        self.emit_blank();
        /* contains — for primitive types and strings */
        Node elem_node = self.analyzer.nodes.get(self.find_type_node_for_mangled(mangled));
        bool is_collection = elem_node.name.equals("List") || elem_node.name.equals("Map");
        bool is_prim = !self.analyzer.has_class(elem_node.name) && !is_collection;
        bool is_str = elem_node.name.equals("string") || elem_node.name.equals("char_ptr") ||
                      (elem_node.name.equals("char") && elem_node.ival >= 1);
        if (is_prim) {
            self.out.writeLine(f"static inline bool {n}_contains({n}* l, {c_type} val) {{");
            self.out.writeLine("    for (int i = 0; i < l->len; i++) {");
            if (is_str) {
                self.out.writeLine("        if (strcmp(l->data[i], val) == 0) return true;");
            } else {
                self.out.writeLine("        if (l->data[i] == val) return true;");
            }
            self.out.writeLine("    }");
            self.out.writeLine("    return false;");
            self.out.writeLine("}");
            self.emit_blank();
        }
        /* remove */
        self.out.writeLine(f"static inline void {n}_remove({n}* l, int idx) {{");
        self.out.writeLine("    for (int i = idx; i < l->len - 1; i++) {");
        self.out.writeLine("        l->data[i] = l->data[i + 1];");
        self.out.writeLine("    }");
        self.out.writeLine("    l->len--;");
        self.out.writeLine("}");
        self.emit_blank();
        /* reverse */
        self.out.writeLine(f"static inline void {n}_reverse({n}* l) {{");
        self.out.writeLine("    for (int i = 0; i < l->len / 2; i++) {");
        self.out.writeLine(f"        {c_type} tmp = l->data[i];");
        self.out.writeLine("        l->data[i] = l->data[l->len - 1 - i];");
        self.out.writeLine("        l->data[l->len - 1 - i] = tmp;");
        self.out.writeLine("    }");
        self.out.writeLine("}");
        self.emit_blank();
        /* sort — for primitive types and strings */
        if (is_prim) {
            self.out.writeLine(f"static int __{n}_cmp(const void* a, const void* b) {{");
            if (is_str) {
                self.out.writeLine("    return strcmp(*(const char**)a, *(const char**)b);");
            } else {
                self.out.writeLine(f"    {c_type} va = *({c_type}*)a;");
                self.out.writeLine(f"    {c_type} vb = *({c_type}*)b;");
                self.out.writeLine("    return (va > vb) - (va < vb);");
            }
            self.out.writeLine("}");
            self.out.writeLine(f"static inline void {n}_sort({n}* l) {{");
            self.out.writeLine(f"    qsort(l->data, l->len, sizeof({c_type}), __{n}_cmp);");
            self.out.writeLine("}");
            self.emit_blank();
        }
        /* pop — remove and return the last element */
        self.out.writeLine(f"static inline {c_type} {n}_pop({n}* l) {{");
        self.out.writeLine("    return l->data[--l->len];");
        self.out.writeLine("}");
        self.emit_blank();
        /* clear */
        self.out.writeLine(f"static inline void {n}_clear({n}* l) {{");
        self.out.writeLine("    l->len = 0;");
        self.out.writeLine("}");
        self.emit_blank();
        /* indexOf — for primitive types and strings */
        if (is_prim) {
            self.out.writeLine(f"static inline int {n}_indexOf({n}* l, {c_type} val) {{");
            self.out.writeLine("    for (int i = 0; i < l->len; i++) {");
            if (is_str) {
                self.out.writeLine("        if (strcmp(l->data[i], val) == 0) return i;");
            } else {
                self.out.writeLine("        if (l->data[i] == val) return i;");
            }
            self.out.writeLine("    }");
            self.out.writeLine("    return -1;");
            self.out.writeLine("}");
            self.emit_blank();
        }
        /* lastIndexOf — for primitive types and strings */
        if (is_prim) {
            self.out.writeLine(f"static inline int {n}_lastIndexOf({n}* l, {c_type} val) {{");
            self.out.writeLine("    for (int i = l->len - 1; i >= 0; i--) {");
            if (is_str) {
                self.out.writeLine("        if (strcmp(l->data[i], val) == 0) return i;");
            } else {
                self.out.writeLine("        if (l->data[i] == val) return i;");
            }
            self.out.writeLine("    }");
            self.out.writeLine("    return -1;");
            self.out.writeLine("}");
            self.emit_blank();
        }
        /* slice */
        self.out.writeLine(f"static inline {n} {n}_slice({n}* l, int start, int end) {{");
        self.out.writeLine(f"    {n} result = {n}_new();");
        self.out.writeLine("    for (int i = start; i < end && i < l->len; i++) {");
        self.out.writeLine(f"        {n}_push(&result, l->data[i]);");
        self.out.writeLine("    }");
        self.out.writeLine("    return result;");
        self.out.writeLine("}");
        self.emit_blank();
        /* join — only for List<string> */
        if (mangled.equals("char_ptr") || mangled.equals("string")) {
            self.out.writeLine(f"static inline char* {n}_join({n}* l, const char* sep) {{");
            self.out.writeLine("    int total = 0;");
            self.out.writeLine("    int sep_len = strlen(sep);");
            self.out.writeLine("    for (int i = 0; i < l->len; i++) {");
            self.out.writeLine("        total += strlen(l->data[i]);");
            self.out.writeLine("        if (i < l->len - 1) total += sep_len;");
            self.out.writeLine("    }");
            self.out.writeLine("    char* result = (char*)malloc(total + 1);");
            self.out.writeLine("    result[0] = '\\0';");
            self.out.writeLine("    for (int i = 0; i < l->len; i++) {");
            self.out.writeLine("        strcat(result, l->data[i]);");
            self.out.writeLine("        if (i < l->len - 1) strcat(result, sep);");
            self.out.writeLine("    }");
            self.out.writeLine("    return result;");
            self.out.writeLine("}");
            self.emit_blank();
        }
        /* forEach(fn) — call fn(element) for each element */
        self.out.writeLine(f"static inline void {n}_forEach({n}* l, void (*fn)({c_type})) {{");
        self.out.writeLine("    for (int i = 0; i < l->len; i++) fn(l->data[i]);");
        self.out.writeLine("}");
        self.emit_blank();
        /* filter(fn) — return new list where fn(element) is true */
        self.out.writeLine(f"static inline {n} {n}_filter({n}* l, bool (*fn)({c_type})) {{");
        self.out.writeLine(f"    {n} result = {n}_new();");
        self.out.writeLine("    for (int i = 0; i < l->len; i++) {");
        self.out.writeLine(f"        if (fn(l->data[i])) {n}_push(&result, l->data[i]);");
        self.out.writeLine("    }");
        self.out.writeLine("    return result;");
        self.out.writeLine("}");
        self.emit_blank();
        /* any(fn) — return true if fn(element) is true for any element */
        self.out.writeLine(f"static inline bool {n}_any({n}* l, bool (*fn)({c_type})) {{");
        self.out.writeLine("    for (int i = 0; i < l->len; i++) { if (fn(l->data[i])) return true; }");
        self.out.writeLine("    return false;");
        self.out.writeLine("}");
        self.emit_blank();
        /* all(fn) — return true if fn(element) is true for all elements */
        self.out.writeLine(f"static inline bool {n}_all({n}* l, bool (*fn)({c_type})) {{");
        self.out.writeLine("    for (int i = 0; i < l->len; i++) { if (!fn(l->data[i])) return false; }");
        self.out.writeLine("    return true;");
        self.out.writeLine("}");
        self.emit_blank();
    }

    private int find_type_node_for_mangled(string mangled) {
        /* Find the type node index whose mangle matches */
        for (int i = 0; i < self.analyzer.nodes.len; i++) {
            Node n = self.analyzer.nodes.get(i);
            if (n.kind == NK_TYPE && n.name.equals(mangled)) {
                return i;
            }
        }
        /* Fallback: return first NK_TYPE with matching name */
        for (int i = 0; i < self.analyzer.nodes.len; i++) {
            Node n = self.analyzer.nodes.get(i);
            if (n.kind == NK_TYPE && self.mangle_type(i).equals(mangled)) {
                return i;
            }
        }
        return 0;
    }

    private void emit_map_functions(string kt, string vt, string km, string vm) {
        string n = f"btrc_Map_{km}_{vm}";
        bool is_str_key = strcmp(kt, "char*") == 0;
        /* String hash function */
        if (is_str_key) {
            self.out.writeLine(f"static inline unsigned int __btrc_hash_str_{km}_{vm}(const char* s) {{");
            self.out.writeLine("    unsigned int h = 5381;");
            self.out.writeLine("    while (*s) h = h * 33 + (unsigned char)*s++;");
            self.out.writeLine("    return h;");
            self.out.writeLine("}");
            self.emit_blank();
        }
        /* new */
        self.out.writeLine(f"static inline {n} {n}_new() {{");
        self.out.writeLine(f"    {n} m;");
        self.out.writeLine("    m.cap = 16;");
        self.out.writeLine("    m.len = 0;");
        self.out.writeLine(f"    m.buckets = ({n}_entry*)calloc(m.cap, sizeof({n}_entry));");
        self.out.writeLine("    return m;");
        self.out.writeLine("}");
        self.emit_blank();
        /* Forward declare put */
        self.out.writeLine(f"static inline void {n}_put({n}* m, {kt} key, {vt} value);");
        self.emit_blank();
        /* resize */
        self.out.writeLine(f"static inline void {n}_resize({n}* m) {{");
        self.out.writeLine("    int old_cap = m->cap;");
        self.out.writeLine(f"    {n}_entry* old_buckets = m->buckets;");
        self.out.writeLine("    m->cap *= 2;");
        self.out.writeLine("    m->len = 0;");
        self.out.writeLine(f"    m->buckets = ({n}_entry*)calloc(m->cap, sizeof({n}_entry));");
        self.out.writeLine("    for (int i = 0; i < old_cap; i++) {");
        self.out.writeLine("        if (old_buckets[i].occupied) {");
        self.out.writeLine(f"            {n}_put(m, old_buckets[i].key, old_buckets[i].value);");
        self.out.writeLine("        }");
        self.out.writeLine("    }");
        self.out.writeLine("    free(old_buckets);");
        self.out.writeLine("}");
        self.emit_blank();
        /* put */
        self.out.writeLine(f"static inline void {n}_put({n}* m, {kt} key, {vt} value) {{");
        self.out.writeLine(f"    if (m->len * 4 >= m->cap * 3) {{ {n}_resize(m); }}");
        if (is_str_key) {
            self.out.writeLine(f"    unsigned int idx = __btrc_hash_str_{km}_{vm}(key) % m->cap;");
        } else {
            self.out.writeLine("    unsigned int idx = (unsigned int)key % m->cap;");
        }
        self.out.writeLine("    while (m->buckets[idx].occupied) {");
        if (is_str_key) {
            self.out.writeLine("        if (strcmp(m->buckets[idx].key, key) == 0) { m->buckets[idx].value = value; return; }");
        } else {
            self.out.writeLine("        if (m->buckets[idx].key == key) { m->buckets[idx].value = value; return; }");
        }
        self.out.writeLine("        idx = (idx + 1) % m->cap;");
        self.out.writeLine("    }");
        self.out.writeLine("    m->buckets[idx].key = key;");
        self.out.writeLine("    m->buckets[idx].value = value;");
        self.out.writeLine("    m->buckets[idx].occupied = true;");
        self.out.writeLine("    m->len++;");
        self.out.writeLine("}");
        self.emit_blank();
        /* get */
        self.out.writeLine(f"static inline {vt} {n}_get({n}* m, {kt} key) {{");
        if (is_str_key) {
            self.out.writeLine(f"    unsigned int idx = __btrc_hash_str_{km}_{vm}(key) % m->cap;");
        } else {
            self.out.writeLine("    unsigned int idx = (unsigned int)key % m->cap;");
        }
        self.out.writeLine("    while (m->buckets[idx].occupied) {");
        if (is_str_key) {
            self.out.writeLine("        if (strcmp(m->buckets[idx].key, key) == 0) return m->buckets[idx].value;");
        } else {
            self.out.writeLine("        if (m->buckets[idx].key == key) return m->buckets[idx].value;");
        }
        self.out.writeLine("        idx = (idx + 1) % m->cap;");
        self.out.writeLine("    }");
        self.out.writeLine(f"    return ({vt}){{0}};");
        self.out.writeLine("}");
        self.emit_blank();
        /* has */
        self.out.writeLine(f"static inline bool {n}_has({n}* m, {kt} key) {{");
        if (is_str_key) {
            self.out.writeLine(f"    unsigned int idx = __btrc_hash_str_{km}_{vm}(key) % m->cap;");
        } else {
            self.out.writeLine("    unsigned int idx = (unsigned int)key % m->cap;");
        }
        self.out.writeLine("    while (m->buckets[idx].occupied) {");
        if (is_str_key) {
            self.out.writeLine("        if (strcmp(m->buckets[idx].key, key) == 0) return true;");
        } else {
            self.out.writeLine("        if (m->buckets[idx].key == key) return true;");
        }
        self.out.writeLine("        idx = (idx + 1) % m->cap;");
        self.out.writeLine("    }");
        self.out.writeLine("    return false;");
        self.out.writeLine("}");
        self.emit_blank();
        /* contains (alias for has) */
        self.out.writeLine(f"static inline bool {n}_contains({n}* m, {kt} key) {{");
        self.out.writeLine(f"    return {n}_has(m, key);");
        self.out.writeLine("}");
        self.emit_blank();
        /* free */
        self.out.writeLine(f"static inline void {n}_free({n}* m) {{");
        self.out.writeLine("    free(m->buckets);");
        self.out.writeLine("    m->buckets = NULL; m->cap = 0; m->len = 0;");
        self.out.writeLine("}");
        self.emit_blank();

        /* remove — find and remove a key, rehashing the cluster */
        self.out.writeLine(f"static inline void {n}_remove({n}* m, {kt} key) {{");
        if (is_str_key) {
            self.out.writeLine(f"    unsigned int idx = __btrc_hash_str_{km}_{vm}(key) % m->cap;");
        } else {
            self.out.writeLine("    unsigned int idx = (unsigned int)key % m->cap;");
        }
        self.out.writeLine("    while (m->buckets[idx].occupied) {");
        if (is_str_key) {
            self.out.writeLine("        if (strcmp(m->buckets[idx].key, key) == 0) {");
        } else {
            self.out.writeLine("        if (m->buckets[idx].key == key) {");
        }
        self.out.writeLine("            m->buckets[idx].occupied = false;");
        self.out.writeLine("            m->len--;");
        self.out.writeLine("            /* Rehash the rest of the cluster */");
        self.out.writeLine("            unsigned int j = (idx + 1) % m->cap;");
        self.out.writeLine("            while (m->buckets[j].occupied) {");
        self.out.writeLine(f"                {kt} rk = m->buckets[j].key;");
        self.out.writeLine(f"                {vt} rv = m->buckets[j].value;");
        self.out.writeLine("                m->buckets[j].occupied = false;");
        self.out.writeLine("                m->len--;");
        self.out.writeLine(f"                {n}_put(m, rk, rv);");
        self.out.writeLine("                j = (j + 1) % m->cap;");
        self.out.writeLine("            }");
        self.out.writeLine("            return;");
        self.out.writeLine("        }");
        self.out.writeLine("        idx = (idx + 1) % m->cap;");
        self.out.writeLine("    }");
        self.out.writeLine("}");
        self.emit_blank();

        /* keys — returns a List<K> of all keys */
        string kl = f"btrc_List_{km}";
        self.out.writeLine(f"static inline {kl} {n}_keys({n}* m) {{");
        self.out.writeLine(f"    {kl} result = {kl}_new();");
        self.out.writeLine("    for (int i = 0; i < m->cap; i++) {");
        self.out.writeLine("        if (m->buckets[i].occupied) {");
        self.out.writeLine(f"            {kl}_push(&result, m->buckets[i].key);");
        self.out.writeLine("        }");
        self.out.writeLine("    }");
        self.out.writeLine("    return result;");
        self.out.writeLine("}");
        self.emit_blank();

        /* values — returns a List<V> of all values */
        string vl = f"btrc_List_{vm}";
        self.out.writeLine(f"static inline {vl} {n}_values({n}* m) {{");
        self.out.writeLine(f"    {vl} result = {vl}_new();");
        self.out.writeLine("    for (int i = 0; i < m->cap; i++) {");
        self.out.writeLine("        if (m->buckets[i].occupied) {");
        self.out.writeLine(f"            {vl}_push(&result, m->buckets[i].value);");
        self.out.writeLine("        }");
        self.out.writeLine("    }");
        self.out.writeLine("    return result;");
        self.out.writeLine("}");
        self.emit_blank();

        /* clear — remove all entries without deallocating */
        self.out.writeLine(f"static inline void {n}_clear({n}* m) {{");
        self.out.writeLine("    for (int i = 0; i < m->cap; i++) m->buckets[i].occupied = false;");
        self.out.writeLine("    m->len = 0;");
        self.out.writeLine("}");
        self.emit_blank();
        /* forEach(fn) — call fn(key, value) for each entry */
        self.out.writeLine(f"static inline void {n}_forEach({n}* m, void (*fn)({kt}, {vt})) {{");
        self.out.writeLine("    for (int i = 0; i < m->cap; i++) {");
        self.out.writeLine("        if (m->buckets[i].occupied) fn(m->buckets[i].key, m->buckets[i].value);");
        self.out.writeLine("    }");
        self.out.writeLine("}");
        self.emit_blank();
    }

    /* ---- Declarations ---- */

    private void emit_globals_and_enums(int prog_idx) {
        Node prog = self.analyzer.nodes.get(prog_idx);
        for (int i = 0; i < prog.items.len; i++) {
            int idx = prog.items.get(i);
            Node decl = self.analyzer.nodes.get(idx);
            if (decl.kind == NK_VAR_DECL || decl.kind == NK_ENUM_DECL) {
                self.emit_decl(idx);
                self.emitted_globals.push(idx);
            }
        }
    }

    private bool is_already_emitted(int idx) {
        for (int i = 0; i < self.emitted_globals.len; i++) {
            if (self.emitted_globals.get(i) == idx) { return true; }
        }
        return false;
    }

    private void emit_declarations(int prog_idx) {
        Node prog = self.analyzer.nodes.get(prog_idx);
        for (int i = 0; i < prog.items.len; i++) {
            int idx = prog.items.get(i);
            if (!self.is_already_emitted(idx)) {
                self.emit_decl(idx);
            }
        }
    }

    private void emit_decl(int idx) {
        Node decl = self.analyzer.nodes.get(idx);
        if (decl.kind == NK_PREPROCESSOR) {
            /* Already emitted in emit_preprocessor_directives */
            return;
        } else if (decl.kind == NK_CLASS_DECL) {
            self.emit_class(idx);
        } else if (decl.kind == NK_FUNC_DECL) {
            self.emit_function(idx);
        } else if (decl.kind == NK_VAR_DECL) {
            self.emit_var_decl_stmt(idx);
        } else if (decl.kind == NK_STRUCT_DECL) {
            self.emit_struct_decl(idx);
        } else if (decl.kind == NK_ENUM_DECL) {
            self.emit_enum_decl(idx);
        } else if (decl.kind == NK_TYPEDEF_DECL) {
            self.emit_typedef_decl(idx);
        }
    }

    /* ---- Class emission ---- */

    private void emit_class(int class_idx) {
        Node decl = self.analyzer.nodes.get(class_idx);
        if (decl.items2.len > 0) { return; } /* Skip generic classes */
        if (!self.analyzer.has_class(decl.name)) { return; }

        ClassInfo cls = self.analyzer.get_class(decl.name);
        self.current_class = decl.name;
        self.analyzer.current_class_name = decl.name;

        /* Emit method forward declarations (skip if overridden later) */
        for (int i = 0; i < cls.method_names.len; i++) {
            string mname = cls.method_names.get(i);
            bool overridden = false;
            for (int j = i + 1; j < cls.method_names.len; j++) {
                string later = cls.method_names.get(j);
                if (later.equals(mname)) { overridden = true; break; }
            }
            if (!overridden) {
                self.emit_method_forward_decl(decl.name, cls, i);
            }
        }

        /* Emit method bodies (skip if overridden later) */
        for (int i = 0; i < cls.method_names.len; i++) {
            string mname = cls.method_names.get(i);
            bool overridden = false;
            for (int j = i + 1; j < cls.method_names.len; j++) {
                string later = cls.method_names.get(j);
                if (later.equals(mname)) { overridden = true; break; }
            }
            if (!overridden) {
                int mnode = cls.method_nodes.get(i);
                self.emit_method(decl.name, cls, mnode);
            }
        }

        /* Emit property accessors */
        for (int i = 0; i < cls.prop_names.len; i++) {
            int pnode_idx = cls.prop_nodes.get(i);
            self.emit_property_accessors(decl.name, pnode_idx);
        }

        /* Emit default constructor if has field defaults or auto-properties but no explicit constructor */
        if (!cls.has_constructor) {
            bool needs_ctor = false;
            for (int i = 0; i < decl.items.len; i++) {
                Node m = self.analyzer.nodes.get(decl.items.get(i));
                if (m.kind == NK_FIELD_DECL && m.n2 != -1) {
                    needs_ctor = true;
                    break;
                }
                if (m.kind == NK_PROPERTY_DECL) {
                    needs_ctor = true;
                    break;
                }
            }
            if (needs_ctor) {
                self.emit_default_constructor(decl.name, class_idx, cls);
            }
        }

        /* Heap allocation helper */
        self.out.writeLine(f"static inline {decl.name}* __btrc_heap_{decl.name}({decl.name} val) {{");
        self.out.writeLine(f"    {decl.name}* ptr = ({decl.name}*)malloc(sizeof({decl.name}));");
        self.out.writeLine("    *ptr = val;");
        self.out.writeLine("    return ptr;");
        self.out.writeLine("}");
        self.emit_blank();

        /* Destroy function */
        self.emit_destroy_function(decl.name, cls);

        self.current_class = "";
        self.analyzer.current_class_name = "";
    }

    private void emit_method_forward_decl(string class_name, ClassInfo cls, int midx) {
        string mname = cls.method_names.get(midx);
        string maccess = cls.method_access.get(midx);
        int mnode_idx = cls.method_nodes.get(midx);
        Node mnode = self.analyzer.nodes.get(mnode_idx);
        bool is_ctor = mname.equals(class_name);
        bool is_static = maccess.equals("class");

        if (is_ctor) {
            self.out.write(f"{class_name} {class_name}_new(");
        } else {
            string ret = self.type_to_c(mnode.n1);
            self.out.write(f"{ret} {class_name}_{mname}(");
        }

        bool first = true;
        if (!is_static && !is_ctor) {
            self.out.write(f"{class_name}* self");
            first = false;
        }
        for (int j = 0; j < mnode.items.len; j++) {
            if (!first) { self.out.write(", "); }
            first = false;
            self.emit_param(mnode.items.get(j));
        }
        if (first) { self.out.write("void"); }
        self.out.writeLine(");");
    }

    private void emit_method(string class_name, ClassInfo cls, int method_idx) {
        Node method = self.analyzer.nodes.get(method_idx);
        bool is_ctor = method.name.equals(class_name);
        bool is_static = method.sval.equals("class");

        /* Signature */
        if (is_ctor) {
            self.out.write(f"{class_name} {class_name}_new(");
        } else {
            string ret = self.type_to_c(method.n1);
            self.out.write(f"{ret} {class_name}_{method.name}(");
        }

        bool first = true;
        if (!is_static && !is_ctor) {
            self.out.write(f"{class_name}* self");
            first = false;
        }
        for (int j = 0; j < method.items.len; j++) {
            if (!first) { self.out.write(", "); }
            first = false;
            self.emit_param(method.items.get(j));
        }
        if (first) { self.out.write("void"); }
        self.out.writeLine(") {");

        self.indent++;
        if (is_ctor) {
            self.emit_raw("");
            self.indent_out();
            self.out.writeLine(f"{class_name} self;");
            /* Apply field defaults */
            for (int fi = 0; fi < cls.field_names.len; fi++) {
                int ft = cls.field_types.get(fi);
                /* Find field decl to check for initializer */
                self.emit_field_default(class_name, cls.field_names.get(fi), ft);
            }
            self.in_constructor = true;
            self.emit_block_contents(method.n2);
            self.in_constructor = false;
            self.indent_out();
            self.out.writeLine("return self;");
        } else {
            self.emit_block_contents(method.n2);
        }
        self.indent--;
        self.out.writeLine("}");
        self.emit_blank();
    }

    private void emit_field_default(string class_name, string fname, int type_idx) {
        /* Search for field initializer in class members — look through all class decls */
        for (int i = 0; i < self.analyzer.nodes.len; i++) {
            Node n = self.analyzer.nodes.get(i);
            if (n.kind == NK_FIELD_DECL && n.name.equals(fname) && n.n2 != -1) {
                string init = self.expr_to_c(n.n2);
                self.indent_out();
                self.out.writeLine(f"self.{fname} = {init};");
                return;
            }
        }
    }

    private void emit_property_accessors(string class_name, int prop_idx) {
        Node prop = self.analyzer.nodes.get(prop_idx);
        string c_type = self.type_to_c(prop.n1);
        bool auto_get = prop.flag1 && prop.n2 == -1;
        bool auto_set = prop.flag2 && prop.n3 == -1;

        /* Getter */
        if (prop.flag1) {
            self.out.writeLine(f"{c_type} {class_name}_get_{prop.name}({class_name}* self) {{");
            self.indent++;
            if (auto_get) {
                self.indent_out();
                self.out.writeLine(f"return self->_{prop.name};");
            } else {
                self.emit_block_contents(prop.n2);
            }
            self.indent--;
            self.out.writeLine("}");
            self.emit_blank();
        }

        /* Setter */
        if (prop.flag2) {
            self.out.writeLine(f"void {class_name}_set_{prop.name}({class_name}* self, {c_type} value) {{");
            self.indent++;
            if (auto_set) {
                self.indent_out();
                self.out.writeLine(f"self->_{prop.name} = value;");
            } else {
                self.emit_block_contents(prop.n3);
            }
            self.indent--;
            self.out.writeLine("}");
            self.emit_blank();
        }
    }

    private void emit_default_constructor(string class_name, int class_idx, ClassInfo cls) {
        Node decl = self.analyzer.nodes.get(class_idx);
        self.out.writeLine(f"{class_name} {class_name}_new(void) {{");
        self.out.writeLine(f"    {class_name} self;");
        self.out.writeLine(f"    memset(&self, 0, sizeof({class_name}));");
        for (int i = 0; i < decl.items.len; i++) {
            Node m = self.analyzer.nodes.get(decl.items.get(i));
            if (m.kind == NK_FIELD_DECL && m.n2 != -1) {
                string init = self.expr_to_c(m.n2);
                self.out.writeLine(f"    self.{m.name} = {init};");
            }
        }
        self.out.writeLine("    return self;");
        self.out.writeLine("}");
        self.emit_blank();
    }

    private void emit_destroy_function(string class_name, ClassInfo cls) {
        self.out.writeLine(f"void {class_name}_destroy({class_name}* self) {{");
        self.out.writeLine("    if (self == NULL) return;");
        /* Call user __del__ if exists */
        int delidx = cls.find_method("__del__");
        if (delidx >= 0) {
            self.out.writeLine(f"    {class_name}___del__(self);");
        }
        /* Recursively destroy class-instance pointer fields, free List/Map fields */
        for (int i = 0; i < cls.field_names.len; i++) {
            string fname = cls.field_names.get(i);
            int ft = cls.field_types.get(i);
            if (ft == -1) { continue; }
            Node ftn = self.analyzer.nodes.get(ft);
            if (ftn.kind != NK_TYPE) { continue; }
            if (ftn.ival > 0 && self.analyzer.has_class(ftn.name)) {
                /* Pointer to another class — recursively destroy */
                self.out.writeLine(f"    {ftn.name}_destroy(self->{fname});");
            } else if (ftn.name.equals("List") && ftn.items.len == 1) {
                string ct = self.type_to_c(ft);
                self.out.writeLine(f"    {ct}_free(&self->{fname});");
            } else if (ftn.name.equals("Map") && ftn.items.len == 2) {
                string ct = self.type_to_c(ft);
                self.out.writeLine(f"    {ct}_free(&self->{fname});");
            }
        }
        self.out.writeLine("    free(self);");
        self.out.writeLine("}");
        self.emit_blank();
    }

    /* ---- Function emission ---- */

    private void emit_function(int func_idx) {
        Node func = self.analyzer.nodes.get(func_idx);
        string ret = self.type_to_c(func.n1);
        self.out.write(f"{ret} {func.name}(");
        bool first = true;
        for (int i = 0; i < func.items.len; i++) {
            if (!first) { self.out.write(", "); }
            first = false;
            self.emit_param(func.items.get(i));
        }
        if (first) { self.out.write("void"); }
        self.out.writeLine(") {");
        self.indent++;
        self.emit_block_contents(func.n2);
        self.indent--;
        self.out.writeLine("}");
        self.emit_blank();
    }

    private void emit_param(int param_idx) {
        Node p = self.analyzer.nodes.get(param_idx);
        string ct = self.type_to_c(p.n1);
        self.out.write(f"{ct} {p.name}");
        /* C-style array suffix */
        if (p.flag1) {
            if (p.n3 != -1) {
                string sz = self.expr_to_c(p.n3);
                self.out.write(f"[{sz}]");
            } else {
                self.out.write("[]");
            }
        }
    }

    /* ---- Struct / Enum / Typedef ---- */

    private void emit_struct_decl(int idx) {
        Node decl = self.analyzer.nodes.get(idx);
        if (decl.items.len > 0) {
            self.out.writeLine(f"typedef struct {decl.name} {{");
            for (int i = 0; i < decl.items.len; i++) {
                Node f = self.analyzer.nodes.get(decl.items.get(i));
                string ct = self.type_to_c(f.n1);
                self.out.writeLine(f"    {ct} {f.name};");
            }
            self.out.writeLine(f"}} {decl.name};");
            self.emit_blank();
        } else {
            self.out.writeLine(f"struct {decl.name};");
            self.emit_blank();
        }
    }

    private void emit_enum_decl(int idx) {
        Node decl = self.analyzer.nodes.get(idx);
        self.out.writeLine("typedef enum {");
        for (int i = 0; i < decl.items.len; i++) {
            Node em = self.analyzer.nodes.get(decl.items.get(i));
            if (em.n1 != -1) {
                string val = self.expr_to_c(em.n1);
                self.out.write(f"    {em.name} = {val}");
            } else {
                self.out.write(f"    {em.name}");
            }
            if (i < decl.items.len - 1) {
                self.out.write(",");
            }
            self.out.writeLine("");
        }
        self.out.writeLine(f"}} {decl.name};");
        self.emit_blank();
    }

    private void emit_typedef_decl(int idx) {
        Node decl = self.analyzer.nodes.get(idx);
        string ct = self.type_to_c(decl.n1);
        self.out.writeLine(f"typedef {ct} {decl.name};");
        self.emit_blank();
    }

    /* ---- Statements ---- */

    private void emit_block_contents(int block_idx) {
        if (block_idx == -1) { return; }
        Node block = self.analyzer.nodes.get(block_idx);
        if (block.kind != NK_BLOCK) { return; }
        for (int i = 0; i < block.items.len; i++) {
            self.emit_stmt(block.items.get(i));
        }
    }

    private void emit_stmt(int idx) {
        if (idx == -1) { return; }
        Node stmt = self.analyzer.nodes.get(idx);

        if (stmt.kind == NK_VAR_DECL) {
            self.emit_var_decl_stmt(idx);
        } else if (stmt.kind == NK_RETURN) {
            if (stmt.n1 != -1) {
                Node ret_expr = self.analyzer.nodes.get(stmt.n1);
                if (ret_expr.kind == NK_FSTRING) {
                    string tmp = self.emit_fstring_as_value(stmt.n1);
                    self.indent_out();
                    self.out.writeLine(f"return {tmp};");
                } else {
                    string val = self.expr_to_c(stmt.n1);
                    self.indent_out();
                    self.out.writeLine(f"return {val};");
                }
            } else {
                self.emit("return;");
            }
        } else if (stmt.kind == NK_IF) {
            self.emit_if_stmt(idx);
        } else if (stmt.kind == NK_WHILE) {
            string cond = self.expr_to_c(stmt.n1);
            self.indent_out();
            self.out.writeLine(f"while ({cond}) {{");
            self.indent++;
            self.emit_block_contents(stmt.n2);
            self.indent--;
            self.emit("}");
        } else if (stmt.kind == NK_DO_WHILE) {
            self.emit("do {");
            self.indent++;
            self.emit_block_contents(stmt.n1);
            self.indent--;
            string cond = self.expr_to_c(stmt.n2);
            self.indent_out();
            self.out.writeLine(f"}} while ({cond});");
        } else if (stmt.kind == NK_FOR_IN) {
            self.emit_for_in(idx);
        } else if (stmt.kind == NK_PARALLEL_FOR) {
            self.emit_parallel_for(idx);
        } else if (stmt.kind == NK_C_FOR) {
            self.emit_c_for(idx);
        } else if (stmt.kind == NK_SWITCH) {
            self.emit_switch(idx);
        } else if (stmt.kind == NK_BREAK) {
            self.emit("break;");
        } else if (stmt.kind == NK_CONTINUE) {
            self.emit("continue;");
        } else if (stmt.kind == NK_EXPR_STMT) {
            string e = self.expr_to_c(stmt.n1);
            self.indent_out();
            self.out.writeLine(f"{e};");
        } else if (stmt.kind == NK_DELETE_STMT) {
            string e = self.expr_to_c(stmt.n1);
            int del_type = self.analyzer.infer_type(stmt.n1);
            if (del_type != -1) {
                Node dt = self.analyzer.nodes.get(del_type);
                if (self.analyzer.has_class(dt.name)) {
                    self.indent_out();
                    self.out.writeLine(f"{dt.name}_destroy({e});");
                } else {
                    self.indent_out();
                    self.out.writeLine(f"free({e});");
                }
            } else {
                self.indent_out();
                self.out.writeLine(f"free({e});");
            }
        } else if (stmt.kind == NK_TRY_CATCH) {
            self.emit_try_catch_stmt(idx);
        } else if (stmt.kind == NK_THROW) {
            string e = self.expr_to_c(stmt.n1);
            self.indent_out();
            self.out.writeLine(f"__btrc_throw({e});");
        } else if (stmt.kind == NK_BLOCK) {
            self.emit("{");
            self.indent++;
            self.emit_block_contents(idx);
            self.indent--;
            self.emit("}");
        }
    }

    private void emit_var_decl_stmt(int idx) {
        Node stmt = self.analyzer.nodes.get(idx);
        int type_idx = stmt.n1;
        /* Handle 'var' inference */
        if (type_idx == -1) {
            if (self.analyzer.var_types.has(idx)) {
                type_idx = self.analyzer.var_types.get(idx);
            } else {
                type_idx = -1;
            }
        }
        /* Function pointer type (from lambda inference) */
        if (type_idx != -1) {
            Node fn_tn = self.analyzer.nodes.get(type_idx);
            if (fn_tn.kind == NK_TYPE && fn_tn.name.equals("__fn_ptr") && fn_tn.items.len > 0) {
                string ret_type = self.type_to_c(fn_tn.items.get(0));
                var param_buf = CharBuffer(128);
                if (fn_tn.items.len <= 1) {
                    param_buf.appendStr("void");
                } else {
                    for (int i = 1; i < fn_tn.items.len; i++) {
                        if (i > 1) { param_buf.appendStr(", "); }
                        param_buf.appendStr(self.type_to_c(fn_tn.items.get(i)));
                    }
                }
                string params = param_buf.toString();
                param_buf.__del__();
                string init = "";
                if (stmt.n2 != -1) {
                    init = self.expr_to_c(stmt.n2);
                }
                self.indent_out();
                if (stmt.n2 != -1) {
                    self.out.writeLine(f"{ret_type} (*{stmt.name})({params}) = {init};");
                } else {
                    self.out.writeLine(f"{ret_type} (*{stmt.name})({params});");
                }
                return;
            }
        }

        string ct = self.type_to_c(type_idx);

        /* Array suffix */
        string suffix = "";
        if (type_idx != -1) {
            Node tn = self.analyzer.nodes.get(type_idx);
            if (tn.kind == NK_TYPE && tn.bval && tn.items.len == 0) {
                suffix = "[]";
            } else if (tn.kind == NK_TYPE && tn.n1 != -1) {
                string sz = self.expr_to_c(tn.n1);
                suffix = f"[{sz}]";
            }
        }
        /* C-style array on var decl */
        if (stmt.flag1) {
            if (stmt.n3 != -1) {
                string sz = self.expr_to_c(stmt.n3);
                suffix = f"[{sz}]";
            } else {
                suffix = "[]";
            }
        }

        if (stmt.n2 != -1) {
            Node init_node = self.analyzer.nodes.get(stmt.n2);
            /* F-string initialization — use snprintf */
            if (init_node.kind == NK_FSTRING) {
                string tmp = self.emit_fstring_as_value(stmt.n2);
                self.indent_out();
                self.out.writeLine(f"{ct} {stmt.name} = {tmp};");
                return;
            }
            /* List literal initialization */
            if (init_node.kind == NK_LIST_LIT) {
                self.indent_out();
                self.out.writeLine(f"{ct} {stmt.name} = {ct}_new();");
                for (int i = 0; i < init_node.items.len; i++) {
                    string elem = self.expr_to_c(init_node.items.get(i));
                    self.indent_out();
                    self.out.writeLine(f"{ct}_push(&{stmt.name}, {elem});");
                }
                return;
            }
            /* Map literal initialization */
            if (init_node.kind == NK_MAP_LIT) {
                self.indent_out();
                self.out.writeLine(f"{ct} {stmt.name} = {ct}_new();");
                for (int i = 0; i < init_node.items.len; i++) {
                    string k = self.expr_to_c(init_node.items.get(i));
                    string v = self.expr_to_c(init_node.items2.get(i));
                    self.indent_out();
                    self.out.writeLine(f"{ct}_put(&{stmt.name}, {k}, {v});");
                }
                return;
            }
            /* Empty {} for Map or List — call _new() instead of C zero-init */
            if (init_node.kind == NK_BRACE_INIT && init_node.items.len == 0 && type_idx != -1) {
                Node tn = self.analyzer.nodes.get(type_idx);
                if (tn.name.equals("Map") || tn.name.equals("List")) {
                    self.indent_out();
                    self.out.writeLine(f"{ct} {stmt.name} = {ct}_new();");
                    return;
                }
            }
            /* Constructor call */
            if (init_node.kind == NK_CALL && init_node.n1 != -1) {
                Node callee = self.analyzer.nodes.get(init_node.n1);
                if (callee.kind == NK_IDENTIFIER && self.analyzer.has_class(callee.name)) {
                    self.indent_out();
                    self.out.write(f"{ct} {stmt.name} = ");
                    string init = self.call_to_c(stmt.n2);
                    self.out.writeLine(f"{init};");
                    return;
                }
            }
            string init = self.expr_to_c(stmt.n2);
            self.indent_out();
            self.out.writeLine(f"{ct} {stmt.name}{suffix} = {init};");
        } else {
            self.indent_out();
            self.out.writeLine(f"{ct} {stmt.name}{suffix};");
        }
    }

    private void emit_if_stmt(int idx) {
        Node stmt = self.analyzer.nodes.get(idx);
        string cond = self.expr_to_c(stmt.n1);
        self.indent_out();
        self.out.writeLine(f"if ({cond}) {{");
        self.indent++;
        self.emit_block_contents(stmt.n2);
        self.indent--;
        if (stmt.n3 != -1) {
            Node else_node = self.analyzer.nodes.get(stmt.n3);
            if (else_node.kind == NK_IF) {
                self.indent_out();
                self.out.write("} else ");
                /* Re-emit the if without indentation prefix */
                string cond2 = self.expr_to_c(else_node.n1);
                self.out.writeLine(f"if ({cond2}) {{");
                self.indent++;
                self.emit_block_contents(else_node.n2);
                self.indent--;
                if (else_node.n3 != -1) {
                    self.emit_else_chain(else_node.n3);
                } else {
                    self.emit("}");
                }
            } else {
                self.emit("} else {");
                self.indent++;
                self.emit_block_contents(stmt.n3);
                self.indent--;
                self.emit("}");
            }
        } else {
            self.emit("}");
        }
    }

    private void emit_else_chain(int idx) {
        Node n = self.analyzer.nodes.get(idx);
        if (n.kind == NK_IF) {
            self.indent_out();
            self.out.write("} else ");
            string cond = self.expr_to_c(n.n1);
            self.out.writeLine(f"if ({cond}) {{");
            self.indent++;
            self.emit_block_contents(n.n2);
            self.indent--;
            if (n.n3 != -1) {
                self.emit_else_chain(n.n3);
            } else {
                self.emit("}");
            }
        } else {
            self.emit("} else {");
            self.indent++;
            self.emit_block_contents(idx);
            self.indent--;
            self.emit("}");
        }
    }

    private void emit_for_in(int idx) {
        Node stmt = self.analyzer.nodes.get(idx);
        /* Check for range() */
        if (stmt.n1 != -1) {
            Node iter = self.analyzer.nodes.get(stmt.n1);
            if (iter.kind == NK_CALL && iter.n1 != -1) {
                Node callee = self.analyzer.nodes.get(iter.n1);
                if (callee.kind == NK_IDENTIFIER && callee.name.equals("range")) {
                    self.emit_range_for(stmt, iter);
                    return;
                }
            }
        }
        /* Collection iteration */
        string iterable = self.expr_to_c(stmt.n1);
        string ivar = f"__btrc_i_{stmt.name}";
        /* Resolve element type from collection type */
        string elem_type = "int";
        int iter_type = self.analyzer.infer_type(stmt.n1);
        if (iter_type != -1) {
            Node itn = self.analyzer.nodes.get(iter_type);
            if ((itn.name.equals("List") || itn.name.equals("Array")) && itn.items.len > 0) {
                elem_type = self.type_to_c(itn.items.get(0));
            }
        }
        self.indent_out();
        self.out.writeLine(f"for (int {ivar} = 0; {ivar} < {iterable}.len; {ivar}++) {{");
        self.indent++;
        self.indent_out();
        self.out.writeLine(f"{elem_type} {stmt.name} = {iterable}.data[{ivar}];");
        self.emit_block_contents(stmt.n2);
        self.indent--;
        self.emit("}");
    }

    private void emit_range_for(Node stmt, Node call) {
        if (call.items.len == 1) {
            string end = self.expr_to_c(call.items.get(0));
            self.indent_out();
            self.out.writeLine(f"for (int {stmt.name} = 0; {stmt.name} < {end}; {stmt.name}++) {{");
        } else if (call.items.len == 2) {
            string start = self.expr_to_c(call.items.get(0));
            string end = self.expr_to_c(call.items.get(1));
            self.indent_out();
            self.out.writeLine(f"for (int {stmt.name} = {start}; {stmt.name} < {end}; {stmt.name}++) {{");
        } else if (call.items.len == 3) {
            string start = self.expr_to_c(call.items.get(0));
            string end = self.expr_to_c(call.items.get(1));
            string step = self.expr_to_c(call.items.get(2));
            self.indent_out();
            self.out.writeLine(f"for (int {stmt.name} = {start}; {stmt.name} < {end}; {stmt.name} += {step}) {{");
        }
        self.indent++;
        self.emit_block_contents(stmt.n2);
        self.indent--;
        self.emit("}");
    }

    private void emit_parallel_for(int idx) {
        Node stmt = self.analyzer.nodes.get(idx);
        string iterable = self.expr_to_c(stmt.n1);
        string ivar = f"__btrc_i_{stmt.name}";
        self.emit("#pragma omp parallel for");
        self.indent_out();
        self.out.writeLine(f"for (int {ivar} = 0; {ivar} < {iterable}.len; {ivar}++) {{");
        self.indent++;
        self.indent_out();
        self.out.writeLine(f"__typeof__({iterable}.data[0]) {stmt.name} = {iterable}.data[{ivar}];");
        self.emit_block_contents(stmt.n2);
        self.indent--;
        self.emit("}");
    }

    private void emit_c_for(int idx) {
        Node stmt = self.analyzer.nodes.get(idx);
        self.indent_out();
        self.out.write("for (");
        /* Init */
        if (stmt.n1 != -1) {
            Node init = self.analyzer.nodes.get(stmt.n1);
            if (init.kind == NK_VAR_DECL) {
                int tinit = init.n1;
                if (tinit == -1 && self.analyzer.var_types.has(stmt.n1)) {
                    tinit = self.analyzer.var_types.get(stmt.n1);
                }
                string ct = self.type_to_c(tinit);
                self.out.write(f"{ct} {init.name}");
                if (init.n2 != -1) {
                    string iv = self.expr_to_c(init.n2);
                    self.out.write(f" = {iv}");
                }
            } else {
                string ie = self.expr_to_c(stmt.n1);
                self.out.write(f"{ie}");
            }
        }
        self.out.write("; ");
        /* Condition */
        if (stmt.n2 != -1) {
            string ce = self.expr_to_c(stmt.n2);
            self.out.write(f"{ce}");
        }
        self.out.write("; ");
        /* Update */
        if (stmt.n3 != -1) {
            string ue = self.expr_to_c(stmt.n3);
            self.out.write(f"{ue}");
        }
        self.out.writeLine(") {");
        self.indent++;
        self.emit_block_contents(stmt.n4);
        self.indent--;
        self.emit("}");
    }

    private void emit_switch(int idx) {
        Node stmt = self.analyzer.nodes.get(idx);
        string val = self.expr_to_c(stmt.n1);
        self.indent_out();
        self.out.writeLine(f"switch ({val}) {{");
        self.indent++;
        for (int i = 0; i < stmt.items.len; i++) {
            int cidx = stmt.items.get(i);
            Node c = self.analyzer.nodes.get(cidx);
            if (c.n1 != -1) {
                string cv = self.expr_to_c(c.n1);
                self.indent_out();
                self.out.writeLine(f"case {cv}:");
            } else {
                self.emit("default:");
            }
            self.indent++;
            for (int j = 0; j < c.items.len; j++) {
                self.emit_stmt(c.items.get(j));
            }
            self.indent--;
        }
        self.indent--;
        self.emit("}");
    }

    private void emit_try_catch_stmt(int idx) {
        Node stmt = self.analyzer.nodes.get(idx);
        self.emit("__btrc_try_top++;");
        self.emit("if (setjmp(__btrc_try_stack[__btrc_try_top]) == 0) {");
        self.indent++;
        self.emit_block_contents(stmt.n1);
        self.emit("__btrc_try_top--;");
        self.indent--;
        self.emit("} else {");
        self.indent++;
        self.indent_out();
        self.out.writeLine(f"const char* {stmt.name} = __btrc_error_msg;");
        self.emit_block_contents(stmt.n2);
        self.indent--;
        self.emit("}");
    }

    /* ---- Expression → C string ---- */

    public string expr_to_c(int idx) {
        if (idx == -1) { return ""; }
        Node n = self.analyzer.nodes.get(idx);

        if (n.kind == NK_INT_LIT) { return n.sval; }
        if (n.kind == NK_FLOAT_LIT) { return n.sval; }
        if (n.kind == NK_STRING_LIT) { return n.sval; }
        if (n.kind == NK_CHAR_LIT) { return n.sval; }
        if (n.kind == NK_BOOL_LIT) { return n.bval ? "true" : "false"; }
        if (n.kind == NK_NULL_LIT) { return "NULL"; }
        if (n.kind == NK_IDENTIFIER) { return n.name; }
        if (n.kind == NK_SELF) { return "self"; }

        if (n.kind == NK_BINARY) {
            /* Null coalescing */
            if (n.op.equals("??")) {
                string left = self.expr_to_c(n.n1);
                string right = self.expr_to_c(n.n2);
                return f"({left} != NULL ? {left} : {right})";
            }
            /* Operator overloading check */
            int left_type = self.analyzer.infer_type(n.n1);
            if (left_type != -1) {
                Node lt = self.analyzer.nodes.get(left_type);
                if (self.analyzer.has_class(lt.name)) {
                    string op_method = self.op_to_method(n.op);
                    if (op_method.len() > 0) {
                        ClassInfo cls = self.analyzer.get_class(lt.name);
                        if (cls.find_method(op_method) >= 0) {
                            string left = self.expr_to_c(n.n1);
                            string right = self.expr_to_c(n.n2);
                            if (lt.ival > 0) {
                                return f"{lt.name}_{op_method}({left}, {right})";
                            } else {
                                return f"{lt.name}_{op_method}(&{left}, {right})";
                            }
                        }
                    }
                }
            }
            /* String operations: +, ==, != */
            if (left_type != -1) {
                Node lt2 = self.analyzer.nodes.get(left_type);
                if (lt2.name.equals("string") || (lt2.name.equals("char") && lt2.ival >= 1)) {
                    string left = self.expr_to_c(n.n1);
                    string right = self.expr_to_c(n.n2);
                    if (n.op.equals("+")) {
                        return f"__btrc_strcat({left}, {right})";
                    }
                    if (n.op.equals("==")) {
                        return f"(strcmp({left}, {right}) == 0)";
                    }
                    if (n.op.equals("!=")) {
                        return f"(strcmp({left}, {right}) != 0)";
                    }
                }
            }
            string left = self.expr_to_c(n.n1);
            string right = self.expr_to_c(n.n2);
            return f"({left} {n.op} {right})";
        }

        if (n.kind == NK_UNARY) {
            /* Unary operator overloading (__neg__) */
            if (n.flag1 && n.op.equals("-")) {
                int operand_type = self.analyzer.infer_type(n.n1);
                if (operand_type != -1) {
                    Node ot = self.analyzer.nodes.get(operand_type);
                    if (self.analyzer.has_class(ot.name)) {
                        ClassInfo cls = self.analyzer.get_class(ot.name);
                        if (cls.find_method("__neg__") >= 0) {
                            string operand = self.expr_to_c(n.n1);
                            if (ot.ival > 0) {
                                return f"{ot.name}___neg__({operand})";
                            } else {
                                return f"{ot.name}___neg__(&{operand})";
                            }
                        }
                    }
                }
            }
            string operand = self.expr_to_c(n.n1);
            if (n.flag1) {
                return f"({n.op}{operand})";
            } else {
                return f"({operand}{n.op})";
            }
        }

        if (n.kind == NK_CALL) {
            return self.call_to_c(idx);
        }

        if (n.kind == NK_INDEX) {
            string obj = self.expr_to_c(n.n1);
            string index = self.expr_to_c(n.n2);
            /* Check if collection type */
            int obj_type = self.analyzer.infer_type(n.n1);
            if (obj_type != -1) {
                Node ot = self.analyzer.nodes.get(obj_type);
                if (ot.name.equals("List") || ot.name.equals("Array")) {
                    if (ot.ival > 0) {
                        return f"{obj}->data[{index}]";
                    } else {
                        return f"{obj}.data[{index}]";
                    }
                }
            }
            return f"{obj}[{index}]";
        }

        if (n.kind == NK_FIELD_ACCESS) {
            return self.field_access_to_c(idx);
        }

        if (n.kind == NK_ASSIGN) {
            /* Check if target is a property setter: obj.prop = value */
            if (n.n1 != -1 && n.op.equals("=")) {
                Node target_node = self.analyzer.nodes.get(n.n1);
                if (target_node.kind == NK_FIELD_ACCESS) {
                    string prop_class = self.get_class_for_obj(target_node.n1);
                    if (prop_class.len() > 0 && self.analyzer.has_class(prop_class)) {
                        ClassInfo cls = self.analyzer.get_class(prop_class);
                        int pidx = cls.find_property(target_node.name);
                        if (pidx >= 0) {
                            Node prop = self.analyzer.nodes.get(cls.prop_nodes.get(pidx));
                            if (prop.flag2) { /* has_setter */
                                string obj_c = self.expr_to_c(target_node.n1);
                                string val_c = self.expr_to_c(n.n2);
                                /* Check if obj is already a pointer */
                                int obj_type = self.analyzer.infer_type(target_node.n1);
                                bool already_ptr = false;
                                if (obj_type != -1) {
                                    Node otn = self.analyzer.nodes.get(obj_type);
                                    already_ptr = otn.ival > 0;
                                }
                                if (target_node.n1 != -1) {
                                    Node on = self.analyzer.nodes.get(target_node.n1);
                                    if (on.kind == NK_SELF) { already_ptr = true; }
                                }
                                if (already_ptr) {
                                    return f"{prop_class}_set_{target_node.name}({obj_c}, {val_c})";
                                } else {
                                    return f"{prop_class}_set_{target_node.name}(&{obj_c}, {val_c})";
                                }
                            }
                        }
                    }
                }
            }
            string target = self.expr_to_c(n.n1);
            /* Handle f-string assignment: emit snprintf first, then assign */
            if (n.n2 != -1 && n.op.equals("=")) {
                Node val_node = self.analyzer.nodes.get(n.n2);
                if (val_node.kind == NK_FSTRING) {
                    string tmp = self.emit_fstring_as_value(n.n2);
                    return f"({target} = {tmp})";
                }
            }
            /* Handle Map/List/empty-brace or empty list literal assignments */
            if (n.n2 != -1) {
                Node val_node = self.analyzer.nodes.get(n.n2);
                bool is_empty_init = (val_node.kind == NK_BRACE_INIT && val_node.items.len == 0) ||
                                     (val_node.kind == NK_LIST_LIT && val_node.items.len == 0) ||
                                     (val_node.kind == NK_MAP_LIT && val_node.items.len == 0);
                if (is_empty_init) {
                    int target_type = self.analyzer.infer_type(n.n1);
                    if (target_type != -1) {
                        Node tt = self.analyzer.nodes.get(target_type);
                        if (tt.name.equals("Map") || tt.name.equals("List")) {
                            string ct = self.type_to_c(target_type);
                            return f"({target} = {ct}_new())";
                        }
                    }
                }
            }
            string value = self.expr_to_c(n.n2);
            /* String += concatenation */
            if (n.op.equals("+=")) {
                int target_type = self.analyzer.infer_type(n.n1);
                if (target_type != -1) {
                    Node tt = self.analyzer.nodes.get(target_type);
                    if (tt.name.equals("string") || (tt.name.equals("char") && tt.ival >= 1)) {
                        return f"({target} = __btrc_strcat({target}, {value}))";
                    }
                }
            }
            return f"({target} {n.op} {value})";
        }

        if (n.kind == NK_TERNARY) {
            string cond = self.expr_to_c(n.n1);
            string te = self.expr_to_c(n.n2);
            string fe = self.expr_to_c(n.n3);
            return f"({cond} ? {te} : {fe})";
        }

        if (n.kind == NK_CAST) {
            string ct = self.type_to_c(n.n1);
            string e = self.expr_to_c(n.n2);
            return f"(({ct}){e})";
        }

        if (n.kind == NK_SIZEOF) {
            if (n.flag1) {
                string ct = self.type_to_c(n.n1);
                return f"sizeof({ct})";
            } else {
                string e = self.expr_to_c(n.n1);
                return f"sizeof({e})";
            }
        }

        if (n.kind == NK_NEW) {
            return self.new_to_c(idx);
        }

        if (n.kind == NK_FSTRING) {
            return self.emit_fstring_as_value(idx);
        }

        if (n.kind == NK_LIST_LIT) {
            return "/* list literal */";
        }

        if (n.kind == NK_MAP_LIT) {
            return "/* map literal */";
        }

        if (n.kind == NK_TUPLE_LIT) {
            return self.tuple_to_c(idx);
        }

        if (n.kind == NK_BRACE_INIT) {
            var cb = CharBuffer(256);
            cb.push('{');
            for (int i = 0; i < n.items.len; i++) {
                if (i > 0) { cb.push(','); cb.push(' '); }
                string e = self.expr_to_c(n.items.get(i));
                for (int j = 0; j < strlen(e); j++) {
                    cb.push(e[j]);
                }
            }
            cb.push('}');
            string result = cb.toString();
            cb.__del__();
            return result;
        }

        if (n.kind == NK_ADDRESS_OF) {
            string e = self.expr_to_c(n.n1);
            return f"(&{e})";
        }

        if (n.kind == NK_DEREF) {
            string e = self.expr_to_c(n.n1);
            return f"(*{e})";
        }

        if (n.kind == NK_LAMBDA) {
            /* Return the pre-assigned C function name */
            return n.sval;
        }

        return "/* unknown expr */";
    }

    /* ---- Call expression ---- */

    /* Fill in default values for missing arguments.
     * params is the List<int> of NK_PARAM node indices from the function/method decl. */
    private string fill_default_args(List<int> call_args, List<int> param_nodes) {
        var ab = CharBuffer(256);
        /* Emit provided arguments */
        for (int i = 0; i < call_args.len; i++) {
            if (i > 0) { ab.appendStr(", "); }
            string a = self.expr_to_c(call_args.get(i));
            ab.appendStr(a);
        }
        /* Fill in defaults for missing args */
        for (int i = call_args.len; i < param_nodes.len; i++) {
            Node p = self.analyzer.nodes.get(param_nodes.get(i));
            if (p.n2 != -1) { /* has default value */
                if (i > 0) { ab.appendStr(", "); }
                string d = self.expr_to_c(p.n2);
                ab.appendStr(d);
            }
        }
        string result = ab.toString();
        ab.__del__();
        return result;
    }

    /* Find the function declaration node by name, returns its param list via items */
    private int find_func_decl(string name) {
        for (int i = 0; i < self.analyzer.nodes.len; i++) {
            Node n = self.analyzer.nodes.get(i);
            if (n.kind == NK_FUNC_DECL && n.name.equals(name)) {
                return i;
            }
        }
        return -1;
    }

    /* Find constructor node for a class */
    private int find_constructor(string class_name) {
        if (!self.analyzer.has_class(class_name)) { return -1; }
        ClassInfo cls = self.analyzer.get_class(class_name);
        int midx = cls.find_method(class_name);
        if (midx >= 0) {
            return cls.method_nodes.get(midx);
        }
        return -1;
    }

    /* Find a method declaration node for a class+method combo */
    private int find_method_decl(string class_name, string method_name) {
        if (!self.analyzer.has_class(class_name)) { return -1; }
        ClassInfo cls = self.analyzer.get_class(class_name);
        int midx = cls.find_method(method_name);
        if (midx >= 0) {
            return cls.method_nodes.get(midx);
        }
        return -1;
    }

    private string call_to_c(int idx) {
        Node expr = self.analyzer.nodes.get(idx);

        if (expr.n1 == -1) { return "/* null callee */"; }
        Node callee = self.analyzer.nodes.get(expr.n1);

        /* Method call: callee is FieldAccessExpr */
        if (callee.kind == NK_FIELD_ACCESS) {
            return self.method_call_to_c(idx);
        }

        /* Constructor call: callee is Identifier and it's a class name */
        if (callee.kind == NK_IDENTIFIER && self.analyzer.has_class(callee.name)) {
            var cb = CharBuffer(256);
            cb.appendStr(callee.name);
            cb.appendStr("_new(");
            /* Fill in default args from constructor */
            int ctor_idx = self.find_constructor(callee.name);
            if (ctor_idx != -1) {
                Node ctor = self.analyzer.nodes.get(ctor_idx);
                string args = self.fill_default_args(expr.items, ctor.items);
                cb.appendStr(args);
            } else {
                for (int i = 0; i < expr.items.len; i++) {
                    if (i > 0) { cb.appendStr(", "); }
                    cb.appendStr(self.expr_to_c(expr.items.get(i)));
                }
            }
            cb.push(')');
            string result = cb.toString();
            cb.__del__();
            return result;
        }

        /* print() builtin */
        if (callee.kind == NK_IDENTIFIER && callee.name.equals("print")) {
            if (!self.analyzer.has_function("print")) {
                return self.print_to_c(idx);
            }
        }

        /* Regular function call with default arg filling */
        var cb = CharBuffer(256);
        cb.appendStr(self.expr_to_c(expr.n1));
        cb.push('(');
        int func_idx = -1;
        if (callee.kind == NK_IDENTIFIER) {
            func_idx = self.find_func_decl(callee.name);
        }
        if (func_idx != -1) {
            Node func = self.analyzer.nodes.get(func_idx);
            string args = self.fill_default_args(expr.items, func.items);
            cb.appendStr(args);
        } else {
            for (int i = 0; i < expr.items.len; i++) {
                if (i > 0) { cb.appendStr(", "); }
                cb.appendStr(self.expr_to_c(expr.items.get(i)));
            }
        }
        cb.push(')');
        string result = cb.toString();
        cb.__del__();
        return result;
    }

    /* ---- Method call ---- */

    private string method_call_to_c(int idx) {
        Node expr = self.analyzer.nodes.get(idx);
        Node access = self.analyzer.nodes.get(expr.n1);
        string method_name = access.name;

        /* Strings.method() — stdlib static dispatch */
        if (access.n1 != -1) {
            Node obj_node = self.analyzer.nodes.get(access.n1);
            if (obj_node.kind == NK_IDENTIFIER && obj_node.name.equals("Strings") &&
                !self.analyzer.has_class("Strings")) {
                return self.strings_static_to_c(method_name, idx);
            }
            if (obj_node.kind == NK_IDENTIFIER && obj_node.name.equals("Math") &&
                !self.analyzer.has_class("Math")) {
                return self.math_static_to_c(method_name, idx);
            }
        }
        /* Static call: ClassName.method() */
        if (access.n1 != -1) {
            Node obj_node = self.analyzer.nodes.get(access.n1);
            if (obj_node.kind == NK_IDENTIFIER && self.analyzer.has_class(obj_node.name)) {
                var cb = CharBuffer(256);
                cb.appendStr( obj_node.name);
                cb.push('_');
                cb.appendStr( method_name);
                cb.push('(');
                int mdecl = self.find_method_decl(obj_node.name, method_name);
                if (mdecl != -1) {
                    Node m = self.analyzer.nodes.get(mdecl);
                    string args = self.fill_default_args(expr.items, m.items);
                    cb.appendStr(args);
                } else {
                    for (int i = 0; i < expr.items.len; i++) {
                        if (i > 0) { cb.push(','); cb.push(' '); }
                        string a = self.expr_to_c(expr.items.get(i));
                        cb.appendStr( a);
                    }
                }
                cb.push(')');
                string result = cb.toString();
                cb.__del__();
                return result;
            }
        }

        string obj_c = self.expr_to_c(access.n1);

        /* String method */
        int obj_type = self.analyzer.infer_type(access.n1);
        if (obj_type != -1) {
            Node ot = self.analyzer.nodes.get(obj_type);
            if (ot.name.equals("string") || (ot.name.equals("char") && ot.ival >= 1)) {
                return self.string_method_to_c(obj_c, method_name, idx);
            }
        }

        /* Collection method */
        if (obj_type != -1) {
            Node ot = self.analyzer.nodes.get(obj_type);
            if (ot.name.equals("List") || ot.name.equals("Array") || ot.name.equals("Map")) {
                return self.collection_method_to_c(obj_type, obj_c, method_name, idx, access.flag1);
            }
        }

        /* Instance method */
        string class_name = self.get_class_for_obj(access.n1);
        if (class_name.len() > 0) {
            bool already_ptr = access.flag1; /* is_arrow */
            if (access.n1 != -1) {
                Node obj_node = self.analyzer.nodes.get(access.n1);
                if (obj_node.kind == NK_SELF && !self.in_constructor) {
                    already_ptr = true;
                }
            }
            var cb = CharBuffer(512);
            cb.appendStr( class_name);
            cb.push('_');
            cb.appendStr( method_name);
            cb.push('(');
            if (already_ptr) {
                cb.appendStr( obj_c);
            } else {
                cb.push('&');
                cb.appendStr( obj_c);
            }
            /* Fill remaining args with defaults if available */
            int mdecl = self.find_method_decl(class_name, method_name);
            if (mdecl != -1) {
                Node m = self.analyzer.nodes.get(mdecl);
                /* Emit provided args */
                for (int i = 0; i < expr.items.len; i++) {
                    cb.appendStr(", ");
                    string a = self.expr_to_c(expr.items.get(i));
                    cb.appendStr(a);
                }
                /* Fill defaults for missing args */
                for (int i = expr.items.len; i < m.items.len; i++) {
                    Node p = self.analyzer.nodes.get(m.items.get(i));
                    if (p.n2 != -1) {
                        cb.appendStr(", ");
                        string d = self.expr_to_c(p.n2);
                        cb.appendStr(d);
                    }
                }
            } else {
                for (int i = 0; i < expr.items.len; i++) {
                    cb.appendStr(", ");
                    string a = self.expr_to_c(expr.items.get(i));
                    cb.appendStr(a);
                }
            }
            cb.push(')');
            string result = cb.toString();
            cb.__del__();
            return result;
        }

        /* Fallback: obj.method(args) or obj->method(args) */
        var cb = CharBuffer(256);
        cb.appendStr( obj_c);
        if (access.flag1) {
            cb.push('-'); cb.push('>');
        } else {
            cb.push('.');
        }
        cb.appendStr( method_name);
        cb.push('(');
        for (int i = 0; i < expr.items.len; i++) {
            if (i > 0) { cb.push(','); cb.push(' '); }
            string a = self.expr_to_c(expr.items.get(i));
            cb.appendStr( a);
        }
        cb.push(')');
        string result = cb.toString();
        cb.__del__();
        return result;
    }

    /* ---- String method translation ---- */

    private string string_method_to_c(string obj_c, string method, int call_idx) {
        Node call = self.analyzer.nodes.get(call_idx);

        if (method.equals("len") || method.equals("byteLen")) {
            return f"(int)strlen({obj_c})";
        }
        if (method.equals("charLen")) {
            return f"__btrc_utf8_charlen({obj_c})";
        }
        if (method.equals("contains")) {
            string arg = self.expr_to_c(call.items.get(0));
            return f"(strstr({obj_c}, {arg}) != NULL)";
        }
        if (method.equals("startsWith")) {
            string arg = self.expr_to_c(call.items.get(0));
            return f"(strncmp({obj_c}, {arg}, strlen({arg})) == 0)";
        }
        if (method.equals("endsWith")) {
            string arg = self.expr_to_c(call.items.get(0));
            return f"(strlen({obj_c}) >= strlen({arg}) && strcmp({obj_c} + strlen({obj_c}) - strlen({arg}), {arg}) == 0)";
        }
        if (method.equals("substring")) {
            var cb = CharBuffer(256);
            cb.appendStr( "__btrc_substring(");
            cb.appendStr( obj_c);
            for (int i = 0; i < call.items.len; i++) {
                cb.push(','); cb.push(' ');
                string a = self.expr_to_c(call.items.get(i));
                cb.appendStr( a);
            }
            cb.push(')');
            string result = cb.toString();
            cb.__del__();
            return result;
        }
        if (method.equals("trim")) {
            return f"__btrc_trim({obj_c})";
        }
        if (method.equals("toUpper")) {
            return f"__btrc_toUpper({obj_c})";
        }
        if (method.equals("toLower")) {
            return f"__btrc_toLower({obj_c})";
        }
        if (method.equals("indexOf")) {
            string arg = self.expr_to_c(call.items.get(0));
            return f"__btrc_indexOf({obj_c}, {arg})";
        }
        if (method.equals("charAt")) {
            string arg = self.expr_to_c(call.items.get(0));
            return f"{obj_c}[{arg}]";
        }
        if (method.equals("equals")) {
            string arg = self.expr_to_c(call.items.get(0));
            return f"(strcmp({obj_c}, {arg}) == 0)";
        }
        if (method.equals("lastIndexOf")) {
            string arg = self.expr_to_c(call.items.get(0));
            return f"__btrc_lastIndexOf({obj_c}, {arg})";
        }
        if (method.equals("replace")) {
            string a0 = self.expr_to_c(call.items.get(0));
            string a1 = self.expr_to_c(call.items.get(1));
            return f"__btrc_replace({obj_c}, {a0}, {a1})";
        }
        if (method.equals("split")) {
            string arg = self.expr_to_c(call.items.get(0));
            return f"__btrc_split({obj_c}, {arg})";
        }
        if (method.equals("repeat")) {
            string arg = self.expr_to_c(call.items.get(0));
            return f"__btrc_repeat({obj_c}, {arg})";
        }
        if (method.equals("count")) {
            string arg = self.expr_to_c(call.items.get(0));
            return f"__btrc_count({obj_c}, {arg})";
        }
        if (method.equals("find")) {
            string a0 = self.expr_to_c(call.items.get(0));
            string a1 = self.expr_to_c(call.items.get(1));
            return f"__btrc_find({obj_c}, {a0}, {a1})";
        }
        if (method.equals("lstrip")) {
            return f"__btrc_lstrip({obj_c})";
        }
        if (method.equals("rstrip")) {
            return f"__btrc_rstrip({obj_c})";
        }
        if (method.equals("capitalize")) {
            return f"__btrc_capitalize({obj_c})";
        }
        if (method.equals("title")) {
            return f"__btrc_title({obj_c})";
        }
        if (method.equals("swapCase")) {
            return f"__btrc_swapCase({obj_c})";
        }
        if (method.equals("padLeft")) {
            string a0 = self.expr_to_c(call.items.get(0));
            string a1 = self.expr_to_c(call.items.get(1));
            return f"__btrc_padLeft({obj_c}, {a0}, {a1})";
        }
        if (method.equals("padRight")) {
            string a0 = self.expr_to_c(call.items.get(0));
            string a1 = self.expr_to_c(call.items.get(1));
            return f"__btrc_padRight({obj_c}, {a0}, {a1})";
        }
        if (method.equals("center")) {
            string a0 = self.expr_to_c(call.items.get(0));
            string a1 = self.expr_to_c(call.items.get(1));
            return f"__btrc_center({obj_c}, {a0}, {a1})";
        }
        if (method.equals("isDigit")) {
            return f"__btrc_isDigitStr({obj_c})";
        }
        if (method.equals("isAlpha")) {
            return f"__btrc_isAlphaStr({obj_c})";
        }
        if (method.equals("isBlank")) {
            return f"__btrc_isBlank({obj_c})";
        }
        if (method.equals("toInt")) {
            return f"atoi({obj_c})";
        }
        if (method.equals("toFloat")) {
            return f"((float)atof({obj_c}))";
        }
        return f"/* unknown string method: {method} */";
    }

    /* ---- Collection method translation ---- */

    private string collection_method_to_c(int type_idx, string obj_c, string method,
                                           int call_idx, bool arrow) {
        Node call = self.analyzer.nodes.get(call_idx);
        Node ot = self.analyzer.nodes.get(type_idx);
        string ct = self.type_to_c(type_idx);

        var cb = CharBuffer(512);
        cb.appendStr( ct);
        cb.push('_');
        cb.appendStr( method);
        cb.push('(');
        if (arrow || ot.ival > 0) {
            cb.appendStr( obj_c);
        } else {
            cb.push('&');
            cb.appendStr( obj_c);
        }
        for (int i = 0; i < call.items.len; i++) {
            cb.push(','); cb.push(' ');
            string a = self.expr_to_c(call.items.get(i));
            cb.appendStr( a);
        }
        cb.push(')');
        string result = cb.toString();
        cb.__del__();
        return result;
    }

    /* ---- Strings static dispatch ---- */

    private string strings_static_to_c(string method, int call_idx) {
        Node call = self.analyzer.nodes.get(call_idx);

        if (method.equals("repeat")) {
            string a0 = self.expr_to_c(call.items.get(0));
            string a1 = self.expr_to_c(call.items.get(1));
            return f"__btrc_repeat({a0}, {a1})";
        }
        if (method.equals("join")) {
            string a0 = self.expr_to_c(call.items.get(0));
            string a1 = self.expr_to_c(call.items.get(1));
            return f"__btrc_join({a0}, {a1})";
        }
        if (method.equals("replace")) {
            string a0 = self.expr_to_c(call.items.get(0));
            string a1 = self.expr_to_c(call.items.get(1));
            string a2 = self.expr_to_c(call.items.get(2));
            return f"__btrc_replace({a0}, {a1}, {a2})";
        }
        if (method.equals("isDigit")) {
            string a0 = self.expr_to_c(call.items.get(0));
            return f"isdigit((unsigned char){a0})";
        }
        if (method.equals("isAlpha")) {
            string a0 = self.expr_to_c(call.items.get(0));
            return f"isalpha((unsigned char){a0})";
        }
        if (method.equals("isAlnum")) {
            string a0 = self.expr_to_c(call.items.get(0));
            return f"isalnum((unsigned char){a0})";
        }
        if (method.equals("isSpace")) {
            string a0 = self.expr_to_c(call.items.get(0));
            return f"isspace((unsigned char){a0})";
        }
        if (method.equals("toInt")) {
            string a0 = self.expr_to_c(call.items.get(0));
            return f"atoi({a0})";
        }
        if (method.equals("toFloat")) {
            string a0 = self.expr_to_c(call.items.get(0));
            return f"((float)atof({a0}))";
        }
        if (method.equals("count")) {
            string a0 = self.expr_to_c(call.items.get(0));
            string a1 = self.expr_to_c(call.items.get(1));
            return f"__btrc_count({a0}, {a1})";
        }
        if (method.equals("find")) {
            string a0 = self.expr_to_c(call.items.get(0));
            string a1 = self.expr_to_c(call.items.get(1));
            string a2 = self.expr_to_c(call.items.get(2));
            return f"__btrc_find({a0}, {a1}, {a2})";
        }
        if (method.equals("rfind")) {
            string a0 = self.expr_to_c(call.items.get(0));
            string a1 = self.expr_to_c(call.items.get(1));
            return f"__btrc_lastIndexOf({a0}, {a1})";
        }
        if (method.equals("capitalize")) {
            string a0 = self.expr_to_c(call.items.get(0));
            return f"__btrc_capitalize({a0})";
        }
        if (method.equals("title")) {
            string a0 = self.expr_to_c(call.items.get(0));
            return f"__btrc_title({a0})";
        }
        if (method.equals("swapCase")) {
            string a0 = self.expr_to_c(call.items.get(0));
            return f"__btrc_swapCase({a0})";
        }
        if (method.equals("padLeft")) {
            string a0 = self.expr_to_c(call.items.get(0));
            string a1 = self.expr_to_c(call.items.get(1));
            string a2 = self.expr_to_c(call.items.get(2));
            return f"__btrc_padLeft({a0}, {a1}, {a2})";
        }
        if (method.equals("padRight")) {
            string a0 = self.expr_to_c(call.items.get(0));
            string a1 = self.expr_to_c(call.items.get(1));
            string a2 = self.expr_to_c(call.items.get(2));
            return f"__btrc_padRight({a0}, {a1}, {a2})";
        }
        if (method.equals("center")) {
            string a0 = self.expr_to_c(call.items.get(0));
            string a1 = self.expr_to_c(call.items.get(1));
            string a2 = self.expr_to_c(call.items.get(2));
            return f"__btrc_center({a0}, {a1}, {a2})";
        }
        if (method.equals("lstrip")) {
            string a0 = self.expr_to_c(call.items.get(0));
            return f"__btrc_lstrip({a0})";
        }
        if (method.equals("rstrip")) {
            string a0 = self.expr_to_c(call.items.get(0));
            return f"__btrc_rstrip({a0})";
        }
        if (method.equals("fromInt")) {
            string a0 = self.expr_to_c(call.items.get(0));
            return f"__btrc_fromInt({a0})";
        }
        if (method.equals("fromFloat")) {
            string a0 = self.expr_to_c(call.items.get(0));
            return f"__btrc_fromFloat({a0})";
        }
        if (method.equals("isDigitStr")) {
            string a0 = self.expr_to_c(call.items.get(0));
            return f"__btrc_isDigitStr({a0})";
        }
        if (method.equals("isAlphaStr")) {
            string a0 = self.expr_to_c(call.items.get(0));
            return f"__btrc_isAlphaStr({a0})";
        }
        if (method.equals("isBlank")) {
            string a0 = self.expr_to_c(call.items.get(0));
            return f"__btrc_isBlank({a0})";
        }
        return f"/* unknown Strings method: {method} */";
    }

    /* ---- Math static dispatch ---- */

    private string math_static_to_c(string method, int call_idx) {
        Node call = self.analyzer.nodes.get(call_idx);

        /* Constants */
        if (method.equals("PI")) {
            return "3.14159265358979323846";
        }
        if (method.equals("E")) {
            return "2.71828182845904523536";
        }
        if (method.equals("TAU")) {
            return "6.28318530717958647692";
        }
        if (method.equals("INF")) {
            return "(1.0 / 0.0)";
        }
        /* Basic operations */
        if (method.equals("abs")) {
            string a0 = self.expr_to_c(call.items.get(0));
            return f"(({a0}) < 0 ? -({a0}) : ({a0}))";
        }
        if (method.equals("fabs")) {
            string a0 = self.expr_to_c(call.items.get(0));
            return f"fabsf({a0})";
        }
        if (method.equals("max")) {
            string a0 = self.expr_to_c(call.items.get(0));
            string a1 = self.expr_to_c(call.items.get(1));
            return f"(({a0}) > ({a1}) ? ({a0}) : ({a1}))";
        }
        if (method.equals("min")) {
            string a0 = self.expr_to_c(call.items.get(0));
            string a1 = self.expr_to_c(call.items.get(1));
            return f"(({a0}) < ({a1}) ? ({a0}) : ({a1}))";
        }
        if (method.equals("fmax")) {
            string a0 = self.expr_to_c(call.items.get(0));
            string a1 = self.expr_to_c(call.items.get(1));
            return f"fmaxf({a0}, {a1})";
        }
        if (method.equals("fmin")) {
            string a0 = self.expr_to_c(call.items.get(0));
            string a1 = self.expr_to_c(call.items.get(1));
            return f"fminf({a0}, {a1})";
        }
        if (method.equals("clamp") || method.equals("fclamp")) {
            string v = self.expr_to_c(call.items.get(0));
            string lo = self.expr_to_c(call.items.get(1));
            string hi = self.expr_to_c(call.items.get(2));
            return f"(({v}) < ({lo}) ? ({lo}) : (({v}) > ({hi}) ? ({hi}) : ({v})))";

        }
        /* Power and roots */
        if (method.equals("power")) {
            string a0 = self.expr_to_c(call.items.get(0));
            string a1 = self.expr_to_c(call.items.get(1));
            return f"powf({a0}, (float)({a1}))";
        }
        if (method.equals("sqrt")) {
            string a0 = self.expr_to_c(call.items.get(0));
            return f"sqrtf({a0})";
        }
        /* Combinatorics */
        if (method.equals("factorial")) {
            string a0 = self.expr_to_c(call.items.get(0));
            return f"__btrc_math_factorial({a0})";
        }
        if (method.equals("gcd")) {
            string a0 = self.expr_to_c(call.items.get(0));
            string a1 = self.expr_to_c(call.items.get(1));
            return f"__btrc_math_gcd({a0}, {a1})";
        }
        if (method.equals("lcm")) {
            string a0 = self.expr_to_c(call.items.get(0));
            string a1 = self.expr_to_c(call.items.get(1));
            return f"__btrc_math_lcm({a0}, {a1})";
        }
        if (method.equals("fibonacci")) {
            string a0 = self.expr_to_c(call.items.get(0));
            return f"__btrc_math_fibonacci({a0})";
        }
        /* Checks */
        if (method.equals("isPrime")) {
            string a0 = self.expr_to_c(call.items.get(0));
            return f"__btrc_math_isPrime({a0})";
        }
        if (method.equals("isEven")) {
            string a0 = self.expr_to_c(call.items.get(0));
            return f"(({a0}) % 2 == 0)";
        }
        if (method.equals("isOdd")) {
            string a0 = self.expr_to_c(call.items.get(0));
            return f"(({a0}) % 2 != 0)";
        }
        /* Trigonometry */
        if (method.equals("sin")) {
            string a0 = self.expr_to_c(call.items.get(0));
            return f"sinf({a0})";
        }
        if (method.equals("cos")) {
            string a0 = self.expr_to_c(call.items.get(0));
            return f"cosf({a0})";
        }
        if (method.equals("tan")) {
            string a0 = self.expr_to_c(call.items.get(0));
            return f"tanf({a0})";
        }
        if (method.equals("asin")) {
            string a0 = self.expr_to_c(call.items.get(0));
            return f"asinf({a0})";
        }
        if (method.equals("acos")) {
            string a0 = self.expr_to_c(call.items.get(0));
            return f"acosf({a0})";
        }
        if (method.equals("atan")) {
            string a0 = self.expr_to_c(call.items.get(0));
            return f"atanf({a0})";
        }
        if (method.equals("atan2")) {
            string a0 = self.expr_to_c(call.items.get(0));
            string a1 = self.expr_to_c(call.items.get(1));
            return f"atan2f({a0}, {a1})";
        }
        /* Rounding */
        if (method.equals("ceil")) {
            string a0 = self.expr_to_c(call.items.get(0));
            return f"ceilf({a0})";
        }
        if (method.equals("floor")) {
            string a0 = self.expr_to_c(call.items.get(0));
            return f"floorf({a0})";
        }
        if (method.equals("round")) {
            string a0 = self.expr_to_c(call.items.get(0));
            return f"((int)roundf({a0}))";
        }
        if (method.equals("truncate")) {
            string a0 = self.expr_to_c(call.items.get(0));
            return f"((int)truncf({a0}))";
        }
        /* Logarithms and exponentials */
        if (method.equals("log")) {
            string a0 = self.expr_to_c(call.items.get(0));
            return f"logf({a0})";
        }
        if (method.equals("log10")) {
            string a0 = self.expr_to_c(call.items.get(0));
            return f"log10f({a0})";
        }
        if (method.equals("log2")) {
            string a0 = self.expr_to_c(call.items.get(0));
            return f"log2f({a0})";
        }
        if (method.equals("exp")) {
            string a0 = self.expr_to_c(call.items.get(0));
            return f"expf({a0})";
        }
        /* Conversions */
        if (method.equals("toRadians")) {
            string a0 = self.expr_to_c(call.items.get(0));
            return f"(({a0}) * 3.14159265358979323846f / 180.0f)";
        }
        if (method.equals("toDegrees")) {
            string a0 = self.expr_to_c(call.items.get(0));
            return f"(({a0}) * 180.0f / 3.14159265358979323846f)";
        }
        /* Utility */
        if (method.equals("sign")) {
            string a0 = self.expr_to_c(call.items.get(0));
            return f"(({a0}) > 0 ? 1 : (({a0}) < 0 ? -1 : 0))";
        }
        if (method.equals("fsign")) {
            string a0 = self.expr_to_c(call.items.get(0));
            return f"(({a0}) > 0.0f ? 1.0f : (({a0}) < 0.0f ? -1.0f : 0.0f))";
        }
        return f"/* unknown Math method: {method} */";
    }

    /* ---- Field access ---- */

    private string field_access_to_c(int idx) {
        Node n = self.analyzer.nodes.get(idx);
        string obj = self.expr_to_c(n.n1);

        /* Check if this is a property getter */
        string prop_class = self.get_class_for_obj(n.n1);
        if (prop_class.len() > 0 && self.analyzer.has_class(prop_class)) {
            ClassInfo cls = self.analyzer.get_class(prop_class);
            int pidx = cls.find_property(n.name);
            if (pidx >= 0) {
                Node prop = self.analyzer.nodes.get(cls.prop_nodes.get(pidx));
                if (prop.flag1) { /* has_getter */
                    /* Check if obj is already a pointer or value type */
                    int obj_type = self.analyzer.infer_type(n.n1);
                    bool already_ptr = false;
                    if (obj_type != -1) {
                        Node otn = self.analyzer.nodes.get(obj_type);
                        already_ptr = otn.ival > 0;
                    }
                    /* self is always a pointer in methods */
                    if (n.n1 != -1) {
                        Node on = self.analyzer.nodes.get(n.n1);
                        if (on.kind == NK_SELF) { already_ptr = true; }
                    }
                    if (already_ptr) {
                        return f"{prop_class}_get_{n.name}({obj})";
                    } else {
                        return f"{prop_class}_get_{n.name}(&{obj})";
                    }
                }
            }
        }

        /* self.field */
        if (n.n1 != -1) {
            Node obj_node = self.analyzer.nodes.get(n.n1);
            if (obj_node.kind == NK_SELF) {
                if (self.in_constructor) {
                    return f"self.{n.name}";
                } else {
                    return f"self->{n.name}";
                }
            }
        }

        /* Optional chaining: obj?.field */
        if (n.flag2) {
            return f"({obj} != NULL ? {obj}->{n.name} : 0)";
        }

        /* Arrow: obj->field */
        if (n.flag1) {
            return f"{obj}->{n.name}";
        }

        /* Dot: obj.field */
        return f"{obj}.{n.name}";
    }

    /* ---- New expression ---- */

    private string new_to_c(int idx) {
        Node n = self.analyzer.nodes.get(idx);
        string ct = self.type_to_c(n.n1);

        if (n.n1 != -1) {
            Node tn = self.analyzer.nodes.get(n.n1);
            if (self.analyzer.has_class(tn.name)) {
                var cb = CharBuffer(256);
                cb.appendStr( "__btrc_heap_");
                cb.appendStr( ct);
                cb.push('(');
                cb.appendStr( ct);
                cb.appendStr( "_new(");
                for (int i = 0; i < n.items.len; i++) {
                    if (i > 0) { cb.push(','); cb.push(' '); }
                    string a = self.expr_to_c(n.items.get(i));
                    cb.appendStr( a);
                }
                cb.appendStr( "))");
                string result = cb.toString();
                cb.__del__();
                return result;
            }
        }
        return f"({ct}*)malloc(sizeof({ct}))";
    }

    /* ---- F-string ---- */

    private string fstring_to_c(int idx) {
        Node n = self.analyzer.nodes.get(idx);
        var fmt_buf = CharBuffer(512);
        var args_buf = CharBuffer(512);
        bool has_args = false;

        fmt_buf.push('"');
        for (int i = 0; i < n.items.len; i++) {
            int part_idx = n.items.get(i);
            Node part = self.analyzer.nodes.get(part_idx);
            if (part.kind == NK_STRING_LIT) {
                /* Text part — escape % for printf */
                for (int j = 0; j < part.sval.len(); j++) {
                    char c = part.sval.charAt(j);
                    if (c == '%') {
                        fmt_buf.push('%');
                        fmt_buf.push('%');
                    } else {
                        fmt_buf.push(c);
                    }
                }
            } else {
                /* Expression part — infer format spec */
                string spec = self.infer_format_spec(part_idx);
                fmt_buf.appendStr( spec);
                if (has_args) {
                    args_buf.appendStr( ", ");
                }
                string e = self.expr_to_c(part_idx);
                args_buf.appendStr( e);
                has_args = true;
            }
        }
        fmt_buf.push('"');

        string fmt = fmt_buf.toString();
        fmt_buf.__del__();

        if (has_args) {
            var result_buf = CharBuffer(1024);
            result_buf.appendStr( fmt);
            result_buf.appendStr( ", ");
            string args = args_buf.toString();
            result_buf.appendStr( args);
            args_buf.__del__();
            string result = result_buf.toString();
            result_buf.__del__();
            return result;
        }
        args_buf.__del__();
        return fmt;
    }

    /* Emit f-string as heap-allocated snprintf value. Returns the temp var name. */
    private string emit_fstring_as_value(int idx) {
        Node n = self.analyzer.nodes.get(idx);
        var fmt_buf = CharBuffer(512);
        var args_buf = CharBuffer(512);
        bool has_args = false;

        fmt_buf.push('"');
        for (int i = 0; i < n.items.len; i++) {
            int part_idx = n.items.get(i);
            Node part = self.analyzer.nodes.get(part_idx);
            if (part.kind == NK_STRING_LIT) {
                for (int j = 0; j < part.sval.len(); j++) {
                    char c = part.sval.charAt(j);
                    if (c == '%') {
                        fmt_buf.push('%');
                        fmt_buf.push('%');
                    } else {
                        fmt_buf.push(c);
                    }
                }
            } else {
                string spec = self.infer_format_spec(part_idx);
                fmt_buf.appendStr(spec);
                if (has_args) {
                    args_buf.appendStr(", ");
                }
                string e = self.expr_to_c(part_idx);
                args_buf.appendStr(e);
                has_args = true;
            }
        }
        fmt_buf.push('"');

        string fmt = fmt_buf.toString();
        fmt_buf.__del__();
        string args = args_buf.toString();
        args_buf.__del__();

        self.fstr_counter++;
        string tmp_name = f"__btrc_fstr_{self.fstr_counter}";
        string tmp = tmp_name;


        /* int __btrc_fstr_N_len = snprintf(NULL, 0, fmt, args); */
        self.indent_out();
        if (has_args) {
            self.out.writeLine(f"int {tmp}_len = snprintf(NULL, 0, {fmt}, {args});");
        } else {
            self.out.writeLine(f"int {tmp}_len = snprintf(NULL, 0, {fmt});");
        }
        /* char* __btrc_fstr_N = (char*)malloc(__btrc_fstr_N_len + 1); */
        self.indent_out();
        self.out.writeLine(f"char* {tmp} = (char*)malloc({tmp}_len + 1);");
        /* snprintf(__btrc_fstr_N, __btrc_fstr_N_len + 1, fmt, args); */
        self.indent_out();
        if (has_args) {
            self.out.writeLine(f"snprintf({tmp}, {tmp}_len + 1, {fmt}, {args});");
        } else {
            self.out.writeLine(f"snprintf({tmp}, {tmp}_len + 1, {fmt});");
        }
        return tmp;
    }

    private string infer_format_spec(int expr_idx) {
        int type_idx = self.analyzer.infer_type(expr_idx);
        if (type_idx != -1) {
            Node tn = self.analyzer.nodes.get(type_idx);
            if (tn.ival > 0 && !tn.name.equals("string") && !tn.name.equals("char")) {
                return "%p";
            }
            if (tn.name.equals("int") || tn.name.equals("short") || tn.name.equals("bool")) {
                return "%d";
            }
            if (tn.name.equals("long")) { return "%ld"; }
            if (tn.name.equals("unsigned") || tn.name.equals("unsigned int")) { return "%u"; }
            if (tn.name.equals("float") || tn.name.equals("double")) { return "%f"; }
            if (tn.name.equals("string")) { return "%s"; }
            if (tn.name.equals("char") && tn.ival > 0) { return "%s"; }
            if (tn.name.equals("char") && tn.ival == 0) { return "%c"; }
        }
        /* Fallback by node kind */
        Node n = self.analyzer.nodes.get(expr_idx);
        if (n.kind == NK_INT_LIT) { return "%d"; }
        if (n.kind == NK_FLOAT_LIT) { return "%f"; }
        if (n.kind == NK_STRING_LIT) { return "%s"; }
        if (n.kind == NK_CHAR_LIT) { return "%c"; }
        return "%d";
    }

    /* ---- print() builtin ---- */

    private string print_to_c(int call_idx) {
        Node call = self.analyzer.nodes.get(call_idx);

        if (call.items.len == 0) {
            return "printf(\"\\n\")";
        }

        /* Single f-string argument */
        if (call.items.len == 1) {
            Node arg = self.analyzer.nodes.get(call.items.get(0));
            if (arg.kind == NK_FSTRING) {
                string fstr = self.fstring_to_c(call.items.get(0));
                /* fstr is "fmt", args — need to insert \n before closing " */
                var cb = CharBuffer(512);
                cb.appendStr( "printf(");
                /* Find the closing " of the format string */
                int fmt_end = -1;
                for (int i = 1; i < strlen(fstr); i++) {
                    if (fstr[i] == '"' && fstr[i-1] != '\\') {
                        fmt_end = i;
                        break;
                    }
                }
                if (fmt_end > 0) {
                    /* Insert \n before the closing quote */
                    for (int i = 0; i < fmt_end; i++) { cb.push(fstr[i]); }
                    cb.appendStr( "\\n");
                    for (int i = fmt_end; i < strlen(fstr); i++) { cb.push(fstr[i]); }
                } else {
                    cb.appendStr( fstr);
                }
                cb.push(')');
                string result = cb.toString();
                cb.__del__();
                return result;
            }
            /* Single string literal */
            if (arg.kind == NK_STRING_LIT) {
                /* Strip quotes, add \n */
                int slen = arg.sval.len();
                var cb = CharBuffer(256);
                cb.appendStr( "printf(\"");
                for (int i = 1; i < slen - 1; i++) { cb.push(arg.sval.charAt(i)); }
                cb.appendStr( "\\n\")");
                string result = cb.toString();
                cb.__del__();
                return result;
            }
        }

        /* General case: auto-format each argument */
        var fmt = CharBuffer(512);
        var args = CharBuffer(512);
        bool has_args = false;

        fmt.push('"');
        for (int i = 0; i < call.items.len; i++) {
            if (i > 0) { fmt.push(' '); }
            Node arg = self.analyzer.nodes.get(call.items.get(i));
            if (arg.kind == NK_STRING_LIT) {
                /* Inline the string literal (strip quotes) */
                int slen = arg.sval.len();
                for (int j = 1; j < slen - 1; j++) { fmt.push(arg.sval.charAt(j)); }
            } else {
                string spec = self.infer_format_spec(call.items.get(i));
                fmt.appendStr( spec);
                if (has_args) { args.appendStr( ", "); }
                string e = self.expr_to_c(call.items.get(i));
                args.appendStr( e);
                has_args = true;
            }
        }
        fmt.appendStr( "\\n\"");
        string fmt_str = fmt.toString();
        fmt.__del__();

        var result_buf = CharBuffer(1024);
        result_buf.appendStr( "printf(");
        result_buf.appendStr( fmt_str);
        if (has_args) {
            result_buf.appendStr( ", ");
            string args_str = args.toString();
            result_buf.appendStr( args_str);
        }
        args.__del__();
        result_buf.push(')');
        string result = result_buf.toString();
        result_buf.__del__();
        return result;
    }

    /* ---- Tuple ---- */

    private string tuple_to_c(int idx) {
        Node n = self.analyzer.nodes.get(idx);
        var cb = CharBuffer(256);
        cb.push('(');
        /* Build tuple struct name from element types */
        cb.appendStr( "btrc_Tuple_");
        for (int i = 0; i < n.items.len; i++) {
            if (i > 0) { cb.push('_'); }
            int et = self.analyzer.infer_type(n.items.get(i));
            if (et != -1) {
                string m = self.mangle_type(et);
                cb.appendStr( m);
            } else {
                cb.appendStr( "int");
            }
        }
        cb.appendStr( "){");
        for (int i = 0; i < n.items.len; i++) {
            if (i > 0) { cb.push(','); cb.push(' '); }
            string e = self.expr_to_c(n.items.get(i));
            cb.appendStr( e);
        }
        cb.push('}');
        string result = cb.toString();
        cb.__del__();
        return result;
    }

    /* ---- Type → C string ---- */

    public string type_to_c(int type_idx) {
        if (type_idx == -1) { return "void"; }
        Node tn = self.analyzer.nodes.get(type_idx);
        if (tn.kind != NK_TYPE) { return "void"; }

        string base = tn.name;
        string stars = "";
        for (int i = 0; i < tn.ival; i++) { stars = stars + "*"; }

        if (base.equals("string")) {
            return f"char*{stars}";
        }
        if (base.equals("List") && tn.items.len > 0) {
            string m = self.mangle_type(tn.items.get(0));
            return f"btrc_List_{m}{stars}";
        }
        if (base.equals("Array") && tn.items.len > 0) {
            string m = self.mangle_type(tn.items.get(0));
            return f"btrc_Array_{m}{stars}";
        }
        if (base.equals("Map") && tn.items.len == 2) {
            string km = self.mangle_type(tn.items.get(0));
            string vm = self.mangle_type(tn.items.get(1));
            return f"btrc_Map_{km}_{vm}{stars}";
        }
        if (base.equals("Tuple") && tn.items.len > 0) {
            string m = self.mangle_type(type_idx);
            return f"btrc_{m}{stars}";
        }

        /* Function pointer type: __fn_ptr<ret, param1, param2, ...> */
        if (base.equals("__fn_ptr") && tn.items.len > 0) {
            /* Return just the return type — actual fn ptr syntax handled in var_decl */
            return self.type_to_c(tn.items.get(0));
        }

        /* Default: base + pointer stars */
        return f"{base}{stars}";
    }

    /* ---- Mangle type ---- */

    public string mangle_type(int type_idx) {
        if (type_idx == -1) { return "void"; }
        Node tn = self.analyzer.nodes.get(type_idx);
        if (tn.kind != NK_TYPE) { return "void"; }

        var cb = CharBuffer(128);
        /* Base name with spaces → underscores */
        for (int i = 0; i < tn.name.len(); i++) {
            char c = tn.name.charAt(i);
            if (c == ' ') { cb.push('_'); } else { cb.push(c); }
        }
        /* Generic args */
        if (tn.items.len > 0) {
            cb.push('_');
            for (int i = 0; i < tn.items.len; i++) {
                if (i > 0) { cb.push('_'); }
                string sub = self.mangle_type(tn.items.get(i));
                cb.appendStr( sub);
            }
        }
        /* Pointer depth */
        for (int i = 0; i < tn.ival; i++) {
            cb.appendStr( "_ptr");
        }
        string result = cb.toString();
        cb.__del__();
        return result;
    }

    /* ---- Helpers ---- */

    private string get_class_for_obj(int obj_idx) {
        if (obj_idx == -1) { return ""; }
        Node obj = self.analyzer.nodes.get(obj_idx);

        /* self → current class */
        if (obj.kind == NK_SELF && self.current_class.len() > 0) {
            return self.current_class;
        }

        /* Infer type */
        int type_idx = self.analyzer.infer_type(obj_idx);
        if (type_idx != -1) {
            Node tn = self.analyzer.nodes.get(type_idx);
            if (self.analyzer.has_class(tn.name)) {
                return tn.name;
            }
        }

        /* Static call: Identifier is a class name */
        if (obj.kind == NK_IDENTIFIER && self.analyzer.has_class(obj.name)) {
            return obj.name;
        }
        return "";
    }

    private string op_to_method(string op) {
        if (op.equals("+")) { return "__add__"; }
        if (op.equals("-")) { return "__sub__"; }
        if (op.equals("*")) { return "__mul__"; }
        if (op.equals("/")) { return "__div__"; }
        if (op.equals("%")) { return "__mod__"; }
        if (op.equals("==")) { return "__eq__"; }
        if (op.equals("!=")) { return "__ne__"; }
        if (op.equals("<")) { return "__lt__"; }
        if (op.equals(">")) { return "__gt__"; }
        if (op.equals("<=")) { return "__le__"; }
        if (op.equals(">=")) { return "__ge__"; }
        return "";
    }

}
